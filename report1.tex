\documentclass[11pt,a4paper,openright]{report}
\usepackage{float}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{pst-rel-points}
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pst-text}
\usepackage{auto-pst-pdf}
\usepackage{etex}
\usepackage{verbatim}
\usepackage{pgfplots} 
\usepackage{courier}
\usepackage{algorithm,algpseudocode}
\usepackage{enumitem}
\usepackage{pdfpages}
% \usepackage{tikze}
\usepackage[notlot,nottoc,notlof]{tocbibind}
\lstset{basicstyle=\footnotesize\ttfamily}
\newcommand{\ngtr}{%
 \mathrel{\ooalign{$>$\cr\hidewidth$|$\hidewidth}}%
}


\pgfplotsset{width=10cm,compat=1.5}
\restylefloat{table}
%\usepackage{ps2pdf}

%%\lstset{language=C}
\title{\textbf{M. Tech Project Stage-II Report}\\ on \\\textbf{Incremental Data flow Analysis using PRISM}}
\vspace{2.5cm}
\author{\emph{by}\\ \\ \bf{Rashmi Rekha Mech}\\\bf{Roll No : 133050089} \\
\\ \emph{Under the Guidance of}\\ \\\textbf{Prof. Uday Khedker}\\}
\date{}


\begin{document}

\maketitle
%\begin{comment}


\includegraphics[width=1.4\textwidth, height=1.2\textheight]{declaration.eps}
\includegraphics[width=\textwidth, height=\textheight]{approval.eps}

% \includepdf{declaration.eps}
% \includepdf{approval.eps}


\chapter*{Acknowledgement}
I would like to express my gratitude to my guide Prof. Uday Khedker, for
his constant motivation, supervision and guidance, during the course of the
project. His suggestions always helped me go forward in the right direction
when the work was stuck.

The project was collaborative project with TATA Research Development and Design Center (TRDDC). I
am greatful to Ravindra Naik and Pavan kumar from TRDDC for their suggestions and support.
Thanks to Prof. Uday Khedkar and Aman Madaan 
for motivating me to write a good report.

This work would not have been complete without the constant motivation of my parents and my dear friends Aman Madaan, Someshwar Dhayalan,
Samson Khess, Abhishek Awasthi, Lucky Agarwal and Praveen Omar. Also I would like to thank my lab mates at the GCC Resource center (GRC) at IIT Bombay.
% \end{Acknowledgement}

\begin{abstract}

When a program undergoes changes during development, updating the
data flow information by doing exhaustive analysis is cost inefficient. In such cases,
modifying the data flow information of the changed portion of the program, while avoiding recomputation of the entire 
data flow can lead to significant savings.

We first describe PRISM, an analyzer generator developed at Tata Research Development and Design Centre (TRDDC).
We next present the enhancements done to the PRISM solver to add the capabilities of incremental analysis, elaborating on the challenges faced and the changes made. 
Such incremental analysis methods are well studied for bit-vector frameworks. 
However, these methods are not directly applicable to general frameworks. 
This report also presents some challenges involved and possible solutions for doing incremental analysis for general frameworks.

\end{abstract}
\newcommand*{\noaddvspace}{\renewcommand*{\addvspace}[1]{}}
\addtocontents{lof}{\protect\noaddvspace}
%\end{comment}
\addtocontents{lof}{\vskip -1.2cm}
\tableofcontents

\listoftables

\listoffigures

\cleardoublepage
\setcounter{page}{1}
\pagenumbering{arabic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Overview}
\section{Introduction}
When a program undergoes changes during development, some or all of data flow information computed earlier becomes invalid.
Thus, re-computation of data flow values is required.
\subsubsection{Motivating Example}

Consider a control flow graph in Fig~\ref{fig:Intro_ex}~\cite{thesis_r} for available expression analysis. Table~\ref{tab:Initial Available_exp}(a) shows 
an initial result which requires three iterations to converge. Suppose, expression $a+b$ in node $n6$ has been removed. To reflect this change, recomputing
data flow information from scratch is shown in Table~\ref{tab:Initial Available_exp}(b). 

The removal of expression $a+b$ does not affect the data flow values and hence no new information is added as shown in Table~\ref{tab:Initial Available_exp}(b).
For such changes, it is not desirable to recompute the information from scratch. This may unnecessarily analyze unaffected program behaviours which 
leads to redundant computation of old values which is very inefficient. 

For such changes, incremental data flow analysis can be used. It modifies only those data flow information which has been affected by 
the change rather than recomputing entire data flow information. Clearly, we expect this method to be more cost-effective than exhaustive analysis in general.



\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(100,90)
% \psframe(0,0)(100,90)
\putnode{n1}{origin}{50}{80}{%
     \psframebox[linewidth=.3,framesep=1.5]{\begin{tabular}{c} $a*b$ \\ $b+d$
                                             
                                            \end{tabular}
}}
\rput(35,80){\rnode{a}{n1}}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.5]{$a+b$}}
\rput(40,65){\rnode{a}{n2}}
\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.5]{$b+d$}}
\rput(20,50){\rnode{a}{n3}}
\putnode{n4}{n3}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.5]{\begin{tabular}{c} $a=1$ \\ $a+b$
                                             \end{tabular}
}}
\rput(15,35){\rnode{a}{n4}}
\putnode{n5}{n2}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.5]{$d=1$}}
\rput(60,35){\rnode{a}{n5}}
\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.5]{$a+b$}}
\rput(60,20){\rnode{a}{n6}}

\putnode{n7}{n6}{0}{-15}{%
   \psframebox[linewidth=.3,framesep=1.5]{%
   \begin{tabular}{c|c|c}
			$a*b$ & $b+d$ & $a+b$\\
			\end{tabular}}}
\rput(40,5){\rnode{a}{Bit Vector}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n2}{n5}
\ncline{->}{n3}{n4}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=19,
		linearc=1,offsetB=1]{->}{n4}{n3}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-10,
		linearc=0.8,offsetB=1, offsetA=2]{->}{n5}{n2}
\ncline{->}{n5}{n6}	
\end{pspicture}
\caption[Control Flow Graph 1]{Control Flow Graph.}
\label{fig:Intro_ex}

\end{figure}


\begin{table}[H]
  \begin{center}
    \begin{tabular}{c}
    \begin{minipage}[b]{0.45\linewidth}\centering 
    \begin{tabular}{c c c c c }
    	\hline
    	   & \multicolumn{2}{c}{$Iteration 1$} & \multicolumn{2}{c}{$Iteration 2$}  \\
    	\hline
    	  Node & In & Out & In & Out \\
   		\midrule
   			  1. & 000 & 110 &  &    \\
   			  2. & 110 & 111 & 100 & 101  \\
   			  3. & 111 & 111 & 000 & 010   \\
   			  4. & 111 & 010 & 010 &   \\
   			  5. & 111 & 101 & 101 &    \\
   			  6. & 101 & 101 & &   \\
	      \bottomrule 
	    \end{tabular}
    	\\
  
	    (a)
    	    	
	\end{minipage}
	\hspace{0.5cm}
	\begin{minipage}[b]{0.45\linewidth}
	\centering
	
    	\begin{tabular}{c c c c c }
    	\hline
    	   & \multicolumn{2}{c}{$Iteration 1$} & \multicolumn{2}{c}{$Iteration 2$}  \\
    	\hline
    	  Node & In & Out & In & Out \\
   		\midrule
   			  1. & 000 & 110 &  &    \\
   			  2. & 110 & 111 & 100 & 101  \\
   			  3. & 111 & 111 & 000 & 010   \\
   			  4. & 111 & 010 & 010 &   \\
   			  5. & 111 & 101 & 101 &    \\
   			  6. & 101 & 101 & &   \\
	      \bottomrule 
	    \end{tabular}	
    	\\
    	
	(b)
    	
    	\end{minipage}
    	
	\end{tabular}    
    \caption[Motivating example for incremental analysis]{(a). Initial available expression analysis for Fig.~\ref{fig:Intro_ex} (b). Exhaustive analysis to validate the program change.}
      \label{tab:Initial Available_exp}
  \end{center}
\end{table}




\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,20)(0,190)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{0}{180}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=\&b$}}
\rput(-12,180){\rnode{a}{n1}}
\rput(-15,176){\rnode{a1}{$\{(a,b)\}$}}

\putnode{n2}{n1}{0}{-18}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(10,162){\rnode{a}{n2}}
\rput(-20,165){\rnode{a1}{$\{(a,b)\}$\blue$\cup \{(c,d)\}$}}
\rput(-20,159){\rnode{a1}{$\{(a,b)\}$\blue$\cup \{(c,d)\}$}}

\putnode{n3}{n2}{-20}{-19}{%
     \psframebox[linewidth=.3,framesep=1.7]{$c=\&d$}}
\rput(-40,147){\rnode{a}{$\{(a,b)\}$\blue$\cup\{(c,d)\}$}}
\rput(-31,143){\rnode{a}{n3}}
\rput(-39,138){\rnode{a}{$\{(a,b),(c,d)\}$}}

\putnode{n4}{n2}{20}{-19}{%
     \psframebox[linewidth=.3,framesep=1.5]{$*c=\&b$}}
\rput(33,143){\rnode{a}{n4}}
\rput(44,149){\rnode{a}{$\{(a,b)\}$\blue$\cup \{(c,d)\}$}}
\rput(37,137){\rnode{a}{$\{(a,b)\}$}}

\putnode{n5}{n2}{0}{-34}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(-10,128){\rnode{a}{n5}}
\rput(-19,132){\rnode{a}{$\{(a,b), (c,d)\}$}}
\rput(-19,124){\rnode{a}{$\{(a,b), (c,d)\}$}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(-10,113){\rnode{a}{n6}}
\rput(-20,117){\rnode{a}{$\{(a,b), (c,d)\}$}}
\rput(-20,109){\rnode{a}{$\{(a,b), (c,d)\}$}}

\rput(0,107){\rnode{a1}{(a)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=4,armB=6,angleA=-90,angleB=90,loopsize=-28,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}

		
		
% \begin{comment}
\putnode{n7}{n1}{0}{-90}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=\&b$}}
\rput(-11,90){\rnode{a}{n1}}


\putnode{n8}{n7}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(10,75){\rnode{a}{n2}}
\rput(-14,79){\rnode{a}{\blue$\{(c,d)\}$}}
\rput(-14,72){\rnode{a}{\blue$\{(c,d)\}$}}

\putnode{n9}{n8}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{$c=\&d$}}
\rput(-32,67){\rnode{a}{\blue$\{(c,d)\}$}}
\rput(-32,60){\rnode{a}{n3}}


\putnode{n10}{n9}{40}{0}{%
     \psframebox[linewidth=.3,framesep=2.5]{$*c=\&b$}}
\rput(32,60){\rnode{a}{n4}}
\rput(20,67){\rnode{a}{\blue$\{(c,d)\}$}}
\rput(24,53){\rnode{a}{\blue$\{(c,d),(d,b)\}$}}


\putnode{n11}{n9}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(-14,42){\rnode{a}{\blue$\{(d,b)\}$}}
\rput(-14,49){\rnode{a}{\blue$\{(d,b)\}$}}
\rput(10,45){\rnode{a}{n5}}


\putnode{n12}{n11}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(10,30){\rnode{a}{n6}}
\rput(-14,34){\rnode{a}{\blue$\{(d,b)\}$}}
\rput(-14,26){\rnode{a}{\blue$\{(d,b)\}$}}
\rput(0,20){\rnode{a1}{(b)}}

\ncline{->}{n7}{n8}
\ncline{->}{n8}{n9}
\ncline{->}{n9}{n11}
\ncline{->}{n8}{n10}
\ncline{->}{n10}{n11}
\ncline{->}{n11}{n12}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
                linearc=0.5,offsetA=2, offsetB=2]{->}{n11}{n8}

% \end{comment}

		
\end{pspicture}
\caption[Incremental analysis across different iterations]{Motivating example for incremental points-to analysis across different iterations. In order to show the increments in 
the sets, we have used $\cup$ instead of writing the values after performing set union.}
   \label{fig:incremental_across_different iteration}
\end{figure}
 
Incremental data flow analysis can be done in the following situations:
\begin{itemize}
\item \textbf{Across different iterations in a fixed point computation:}\newline
Instead of computing all values afresh in each iteration of an analysis, the values can be accumulated across iterations. If each iteration 
computes only the values not computed before, or modifies the values that needs to change will eliminate redundant computation of old values.

Consider points-to analysis in figure~\ref{fig:incremental_across_different iteration}. After first iteration, at IN of node $n2$ points-to pair (c,d) is added 
to the pointer set. At node $n4$, we modify only the pointees of c. Hence, pointer information of c is only required to generate new points-to pairs. 
After first iteration, computation of pair $(a,b)$ at IN of node $n4$ is redundant. 
The generated new data flow values in an iteration are known as incremental values (figure~\ref{fig:incremental_across_different iteration}(b) shows
incremental values). Therefore, propagating the incremental values during the analysis can reduce the redundant computations at a basic block.

\item \textbf{Across different applications of an analysis:} \newline
Let us consider the example shown in figure~\ref{fig:acr_app}. After performing available expression analysis, we have a scope of doing constant propagation 
analysis. After first pass of available expression analysis, expressions $x+1$ and $a+b$ are available at the OUT of $n2$. At the OUT of $n1$, the value of $x$ 
is $10$. Therefore, after first pass of constant propagation the value of $y$ (at the OUT of $n2$) becomes 11. This can be further optimized by directly
propagating the value of variable y in print statement. Now, if we further perform dead code elimination on the modified graph. The dead 
statements at node $n1$ and $n2$ will be removed as shown in Fig~\ref{fig:acr_app}(c). Hence, information of availability of expressions stored with 
the modified graph should be updated.	

Therefore, incremental analysis is performed on the modified control flow graph using updated information.

\end{itemize}
\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(150,50)
%\psframe(0,0)(150,50)
\putnode{n1}{origin}{25}{40}{%
     \psframebox[linewidth=.3,framesep=2.5]{$x=10$}}
\rput(13,40){\rnode{a}{n1}}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.5]{%
				\begin{tabular}{c}
					$y=x+1$ \\ 
					$x=a+b$ \\
				\end{tabular}}}
\rput(08,25){\rnode{a}{n2}}
\putnode{n3}{n2}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{print $x+y$}}
\rput(10,10){\rnode{a}{n3}}
\rput(25,2){\rnode{1}{(a)}}


\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}

\putnode{n11}{origin}{75}{40}{%
     \psframebox[linewidth=.3,framesep=2.5]{$x=10$}}
\rput(63,40){\rnode{a1}{n1}}
\putnode{n12}{n11}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.5]{%
				\begin{tabular}{c}
					$y=10+1$ \\ 
					$x=a+b$ \\
				\end{tabular}}}
\rput(57,25){\rnode{a2}{n2}}
\putnode{n13}{n12}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{print $x+11$}}
\rput(60,10){\rnode{a3}{n3}}
\rput(74,2){\rnode{2}{(b)}}
\ncline{->}{n11}{n12}
\ncline{->}{n12}{n13}


\putnode{n21}{origin}{125}{40}{%
     \psframebox[linewidth=.3,framesep=3.5]{\hspace{10mm}}}
\rput(113,40){\rnode{a4}{n1}}
\putnode{n22}{n21}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{$x=a+b$}}
\rput(110,25){\rnode{a5}{n2}}
\putnode{n23}{n22}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{print $x+11$}}
\rput(110,10){\rnode{a6}{n3}}
\rput(125,2){\rnode{3}{(c)}}
\ncline{->}{n21}{n22}
\ncline{->}{n22}{n23}



%\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-17,
%		linearc=0.5,offsetB=1]{->}{n3}{n2}
\end{pspicture}
\caption[Incremental analysis across different applications.]{Incremental analysis across different applications.}
   \label{fig:acr_app}
\end{figure}


\section{Scope of the Project}

This project aims at providing support for incremental data flow analysis in PRISM.
Old version of PRISM~\cite{thesis_v} performs both unidirectional and bi-directional context sensitive analysis. 
However, it doesn't perform incremental data flow analysis.

This report explains the implemented incremental solver. It also presents some issues in implementing incremental data flow analysis for general
frameworks. It describes the implemented Liveness-based Inter-procedural Reaching Definition Analysis in PRISM.




\section{Organization of the Report}
The report is organized as follows. Chapter 2 describes incremental analysis for bit-vector frameworks.
Chapter 3 focuses on an overview of PRISM. Chapter 4 describes our implementation of Liveness-based Reaching Definition analysis in 
PRISM. Our addition to PRISM and performance measurement is described in Chapter 5.
Chapter 6 describes some of issues in doing incremental analysis for general frameworks. Chapter 7 describes some extensions
that can be made to the current work. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Incremental Data Flow Analysis}
A Data Flow framework~\cite{thesis_sir} is defined as a triple $D =\langle L,\sqcap,F\rangle$, where $L$ represents information associated 
with entry/exit of a basic block ($L$ is a partially ordered set ), $\sqcap$ represents a binary meet operation (e.g intersection or union) 
which determines the way the global information is combined when it reaches a basic block, and $F$ represents a flow function. 
There are two special elements are associated with this framework, $top$ denoted by $\top$ and $bot$ denoted by $\bot$, 
which can be defined as follows:
\begin{itemize}
\item {Top.}
$\forall x \in L : x \sqcap \top = x $ 

(Using $\top$, in place of any data flow value, will never miss out any possible value. Hence, it is an exhaustive approximation of all values.)

\item {Bottom.}
$\forall x \in L : x \sqcap \bot =\bot $

(Using $\bot$, in place of any data flow value, will never be incorrect. Hence it is a safe approximation of all values.)


\end{itemize}

When a program undergoes changes during development some or all data flow information computed earlier becomes invalid. 
Updating data flow information to incorporate the effect of changes by repeating an exhaustive analysis can be very cost inefficient since
it may compute redundant values. So incremental data flow analysis can be used. It modifies only those data flow information which has been
affected by the change. So is more cost-effective than an exhaustive analysis.

When a program gets modified, the changes in the old data flow information may take place either globally or locally. Local changes
are those which are associated with the node in which the original change has taken place. Global changes are those which are associated with some
other node. Global changes can be found by incorporating the effect of local changes over the rest of the nodes of the graph. Incremental Data flow
analysis basically focuses on global changes.


\section{Incremental Analysis for Bit-vector Frameworks}
In this section, first we describe the flow functions associated with bit-vector frameworks. Then we briefly describes the possible changes in bit-vector 
frameworks and how to handle those changes. 
\subsection{Flow Functions in Bit-vector Frameworks}
In bit-vector analysis, following types of functions are possible. 
\begin{itemize}
 \item Raise : Result is always top ($\top$). Consider an available expression analysis in figure~\ref{fig:flow_func}(a). At node n2, \textit{GEN}
 is 1 and \textit{KILL} is 0. Therefore, \textit{OUT}$_2 = 1$ or $\top$ ( \textit{OUT}$_n =$ \textit{GEN} $\cup$ (\textit{IN}$_n$ - \textit{KILL}) ). 
 Flow function at n2 is a Raise function whose result is always $\top$
 
 \item Lower : Result is always bottom ($\bot$). Consider an available expression analysis in figure~\ref{fig:flow_func}(b). At node n2, \textit{GEN}
 is 0 and \textit{KILL} is 1. Therefore, \textit{OUT}$_2 = 0$ or $\bot$. Flow function at n2 is a Lower function whose result is always $\bot$
 
 \item Propagate : It propagates the value at IN to OUT of the node. Consider an available expression analysis in 
 figure~\ref{fig:flow_func}(b). At node n3, \textit{GEN} is 0 and \textit{KILL} is 0. Therefore, \textit{OUT}$_3 =$\textit{IN}$_3$ . 
 Flow function at n3 propagates the value at the IN to OUT of the node n3	
 
 
 \begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(0,50)
%%\psframe(0,0)(50,50)
\putnode{n1}{origin}{-10}{40}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n1}{-10}{0}{n1}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$b*c$}}
\putnode{a}{n2}{-10}{0}{n2}
\putnode{n3}{n2}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n3}{-10}{0}{n3}
\putnode{a1}{n3}{0}{-10}{(a)}


\putnode{n12}{n1}{30}{0}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$a*b$}}
\putnode{a}{n12}{-10}{0}{n1}
\putnode{n22}{n12}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$a=$}}
\putnode{a}{n22}{-10}{0}{n2}
\putnode{n32}{n22}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n32}{-10}{0}{n3}
\putnode{a2}{n32}{0}{-10}{(b)}


\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n12}{n22}
\ncline{->}{n22}{n32}
\ncline{->}{n13}{n23}
\ncline{->}{n23}{n33}
\end{pspicture}
\caption[Three possible flow functions]{Flow functions in bit-vector frameworks}
   \label{fig:flow_func}
\end{figure}

 
\end{itemize}


\label{sec:bit-vector}
\subsection{Possible Changes in Flow Functions}
For a given entity, the following changes could happen as a consequence of some change in a node:
\begin{itemize}
\item some data flow values may change from top ($\top$) to bottom ($\bot$). Possible changes in the flow function is shown in fig~\ref{fig:flow_func_top_to_bot}(a) 
\item some data flow values may change from bottom ($\bot$) to top ($\top$). Possible changes in the flow function is shown in fig~\ref{fig:flow_func_top_to_bot}(b)
\item some data flow values may remain same.
\end{itemize}

 \begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,10)(0,60)
%%\psframe(0,0)(50,50)
\putnode{n1}{origin}{-50}{40}{%
     \psframebox[linewidth=.3,framesep=2.5]{raise}}
 \putnode{a}{n1}{0}{10}{\textit{old}}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{propagate}}
%  \putnode{a}{n2}{-10}{0}{n2}


\putnode{n12}{n1}{30}{0}{%
     \psframebox[linewidth=.3,framesep=2.5]{lower}}
 \putnode{a}{n12}{0}{10}{\textit{new}}
\putnode{n22}{n12}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{propagate}}
% \putnode{a}{n22}{-10}{0}{n2}
\putnode{a1}{n2}{15}{-10}{(a)}
\ncline{->}{n1}{n12}
\ncline{->}{n1}{n22}
\ncline{->}{n2}{n12}

\psline[linestyle=dotted](-35,50)(-35,20)

\putnode{n1}{origin}{20}{40}{%
     \psframebox[linewidth=.3,framesep=2.5]{lower}}
 \putnode{a}{n1}{0}{10}{\textit{old}}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{propagate}}
%  \putnode{a}{n2}{-10}{0}{n2}


\putnode{n12}{n1}{30}{0}{%
     \psframebox[linewidth=.3,framesep=2.5]{raise}}
 \putnode{a}{n12}{0}{10}{\textit{new}}
\putnode{n22}{n12}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{propagate}}
% \putnode{a}{n22}{-10}{0}{n2}
\putnode{a1}{n2}{15}{-10}{(b)}
\ncline{->}{n1}{n12}
\ncline{->}{n1}{n22}
\ncline{->}{n2}{n12}

\psline[linestyle=dotted](35,50)(35,20)
\end{pspicture}
\caption[Three possible flow functions]{Flow functions in Bit-vector framework (a) Possible changes in flow function for top to bottom change. (b) Possible changes
in flow functions for bottom to top change.}
   \label{fig:flow_func_top_to_bot}
\end{figure}





\subsubsection{Handling Top to Bottom Change}
Given that $\forall x \in L : x \sqcap \top = x$, a top value for a data flow property is an intermediate value until the analysis is
completed. But in case of a bottom value, $\forall x \in L : x \sqcap \bot =\bot $. Thus, a bottom value is a final value even during analysis. So whenever 
there is a top to bottom change in a program, the changes can be propagated directly to its neighbouring nodes.

Consider an example of available expressions analysis for the control flow graph in figure~\ref{fig:top_to_bot_bitvector}. In this case, the expression 
$b*c$ is available at the OUT of both node n1 and n3 (i.e. the data flow value for $b*c$ is top) and so is available at the IN of $n2$. Let an assignment
``$c=$" be inserted after the computation of $b*c$ in node $n3$. After this change, $b*c$ is not available at the OUT of node n3, i.e. top to bottom change
(refer to figure~\ref{fig:flow_func_top_to_bot}) at the OUT of $n3$ which in turn makes bottom at the IN of $n2$ since \textit{IN}$_2 = $\textit{OUT}$_1 \cap$ \textit{OUT}$_3 $,
which implies that the value of \textit{IN}$_2 $ is determined by the value of \textit{OUT}$_3$ alone. Thus, the effect of top to bottom change
can be incorporated by directly propagating the change to its neighbour. 

\begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(50,50)
%%\psframe(0,0)(50,50)
\putnode{n1}{origin}{25}{40}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$b*c$}}
\rput(15,40){\rnode{a}{n1}}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=3.5, framearc=.4]{\hspace{10mm}}}
\rput(12,25){\rnode{a}{n2}}
\putnode{n3}{n2}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$b*c$}}
\rput(15,10){\rnode{a}{n3}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-17,
		linearc=0.5,offsetB=1]{->}{n3}{n2}
\end{pspicture}
\caption[Example for top to bottom change in bit-vector framework]{Top to Bottom change in control flow graph}
   \label{fig:top_to_bot_bitvector}
\end{figure}

\subsubsection{Handling Bottom to Top Change}
Bottom value is a final value even during the analysis. Thus, whenever there is a bottom to top change we cannot directly propagate the changes to its neighbours. 
We need some more processing to incorporate this change.

Consider control flow graph in figure~\ref{fig:top_to_bot_bitvector}, if there is a bottom to top change (figure~\ref{fig:flow_func_top_to_bot}) at the OUT of $n3$, the value of \textit{IN}$_2$ cannot be directly 
determined by \textit{OUT}$_3$ alone since now it depends on the value of \textit{OUT}$_1$ also. Therefore, incorporating the effect of bottom to top change requires some more processing.

The effect of bottom to top change can be incorporated in the following two steps:
\begin{itemize}
\item{Identify the data flow values which may become top.}
\item{Find out the data flow values, identified in the above step, which must remain bottom due to the effect of some other property.}
\end{itemize}

\begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,15)(100,80)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{50}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a+b$}}
\rput(40,80){\rnode{a}{n1}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{$a*b$}}
\rput(40,65){\rnode{a}{n2}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=2$}}
\rput(20,50){\rnode{a}{n3}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(57,50){\rnode{a}{n4}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{$a*c$}}
\rput(40,35){\rnode{a}{n5}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(37,20){\rnode{a}{n6}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-30,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}
		
\end{pspicture}
\caption[Bottom to Top motivating example]{Control flow graph for available expression analysis}
   \label{fig:bottom_to_top_motivating_ex}
\end{figure}


\subsubsection{Motivating Example}
Consider a control flow graph as shown in Fig~\ref{fig:bottom_to_top_motivating_ex}. Table~\ref{tab:table_available_exp_bot_to_top} shows the result of available expression 
analysis for Fig~\ref{fig:bottom_to_top_motivating_ex}.



\begin{table}[H]	
  \begin{center}
     % \label{tab:Available_exp}
    \begin{tabular}{c c c c c c c}
    \hline
       & \multicolumn{2}{c}{$a+b$} & \multicolumn{2}{c}{$a*b$} & \multicolumn{2}{c}{$a*c$} \\
    \hline
      Node & In & Out & In & Out & In & Out\\
   	\midrule
   	  1. & 0 & 1 & 0 & 0 & 0 & 0 \\
   	  2. & 0 & 0 & 0 & 1 & 0 & 0 \\
   	  3. & 0 & 0 & 1 & 0 & 0 & 0 \\
   	  4. & 0 & 0 & 1 & 1 & 0 & 0 \\
   	  5. & 0 & 0 & 0 & 0 & 0 & 1 \\
   	  6. & 0 & 0 & 0 & 0 & 1 & 1\\
      
      \bottomrule 
    \end{tabular}
    \caption{Available expression analysis for Fig.~\ref{fig:bottom_to_top_motivating_ex}}
      \label{tab:table_available_exp_bot_to_top}
  \end{center}
\end{table}


Assume that the expression ``$b=2$" in $n3$ has been deleted. Now, we will calculate the updated information in following two steps:
\begin{itemize}
\item{The data flow values which were 0 and $may$ become 1 due to this change (shown in Table~\ref{tab:Available_exp_which_may_1})}

At node $n3$, the expression ``$b=2$'' is killing the availability of expressions $a*b$ and $a+b$. So after the removal of $b=2$, 
expression $a*b$ and $a+b$ may available at the OUT of $n3$ which in turn affects many other nodes. So, we will construct an \textbf{affected region}.  
The affected region is a set of program points where information may change. The affected region for fig~\ref{fig:bottom_to_top_motivating_ex} includes $\langle$ \textit{OUT}$_3,$ \textit{IN}$_5 ,$\textit{OUT}$_5,$
\textit{IN}$_6,$ \textit{OUT}$_6,$ \textit{IN}$_2 ,$ \textit{OUT}$_2,$ \textit{IN}$_4,$ \textit{OUT}$_4,$ \textit{IN}$_3 \rangle$ 
program points.


\begin{table}[H]
  \begin{center}
      %\label{tab:Available_exp}
    \begin{tabular}{c c c c c c c }
    \hline
       & \multicolumn{2}{c}{$a+b$} & \multicolumn{2}{c}{$a*b$} & \multicolumn{2}{c}{$a*c$} \\
    \hline
      Node & In & Out & In & Out & In & Out\\
   	\midrule
   	  1. &  &  &  &  &  &  \\
   	  2. & 1 & 1 & 1 &  &  &  \\
   	  3. & 1 & 1 &  & 1 &  &  \\
   	  4. & 1 & 1 &  &  &  &  \\
   	  5. & 1 & 1 & 1 & 1 &  &  \\
   	  6. & 1 & 1 & 1 & 1 &  & \\
      
      \bottomrule 
    \end{tabular}
    \caption{The data flow values which may become 1.}
      \label{tab:Available_exp_which_may_1}
  \end{center}
\end{table}

\item{From the data flow values shown in Table~\ref{tab:Available_exp_which_may_1}, the data flow values which must remain 0 are shown in 
Table~\ref{tab:Available_exp_which_remain_0}}

This step is again divided in two following parts:

\begin{itemize}
\item \textbf{Identifying boundary nodes}: Boundary nodes are those where some information comes from an unaffected part of the program. We need to consider 
those information to compute the data flow values. In Fig~\ref{fig:bottom_to_top_motivating_ex}, $n2$ is a boundary node. To calculate \textit{IN}$_2$ we need to consider
\textit{OUT}$_5 \sqcap$ \textit{OUT}$_1$, where $n1$ is a node in unaffected region. 

\item  \textbf{Computing values at boundary nodes and propagating them}.

At \textit{OUT}$_1$, $a*b$ is not available which makes $a*b$ not available at \textit{IN}$_2$. But $a+b$ is available at both \textit{OUT}$_1$ and \textit{OUT}$_5$ and hence is available at \textit{IN}$_2$.
After computing the information at the \textit{IN}$_2$, we will propagate this information throughout the affected region. The resultant values which must remain 0 are shown
in Table~\ref{tab:Available_exp_which_remain_0}
\end{itemize}

\begin{table}[H]
  \begin{center}
      %\label{tab:Available_exp1}
    \begin{tabular}{c c c c c c c }
    \hline
       & \multicolumn{2}{c}{$a+b$} & \multicolumn{2}{c}{$a*b$} & \multicolumn{2}{c}{$a*c$} \\
    \hline
      Node & In & Out & In & Out & In & Out\\
   	\midrule
   	  1. &  &  &  &  &  &  \\
   	  2. &  &  &0&  &  &  \\
   	  3. &  &  &  &  &  &  \\
   	  4. &  &  &  &  &  &  \\
   	  5. &  &  &  &  &  &  \\
   	  6. &  &  &  &  &  & \\
      
      \bottomrule 
    \end{tabular}
    \caption{The data flow values which must remain 0.}
      \label{tab:Available_exp_which_remain_0}
  \end{center}
\end{table}

\end{itemize}  

Thus, the final solution is shown in Table~\ref{tab:Available_exp_final_solution}

\begin{table}[H]
  \begin{center}
      %\label{tab:Available_exp}
    \begin{tabular}{c c c c c c c }
    \hline
       & \multicolumn{2}{c}{$a+b$} & \multicolumn{2}{c}{$a*b$} & \multicolumn{2}{c}{$a*c$} \\
    \hline
      Node & In & Out & In & Out & In & Out\\
   	\midrule
   	  1. & 0 & 1 &0 & 0 & 0 & 0 \\
   	  2. & 1 & 1 & 0 & 1 & 0 & 0  \\
   	  3. & 1 & 1 & 1 & 1 & 0 & 0 \\
   	  4. & 1 & 1 & 1 & 1 & 0 & 0 \\
   	  5. & 1 & 1 & 1 & 1& 0 & 1 \\
   	  6. & 1 & 1 & 1 & 1 & 1 & 1\\
      
      \bottomrule 
    \end{tabular}
    \caption{Final updated information.}
      \label{tab:Available_exp_final_solution}
  \end{center}
\end{table}

% multiple changes
The above example is for a single change in graph. Since we are computing data flow values at boundary nodes and propagating the values to its neighboring nodes, we can
easily extend this method for multiple changes in the control graph.

Let two values $v_1$ and $v_2$ are reaching at a program point $u$ and $v_1$ be a lower value than $v_2$. Then the value at $u$ will be the lowest value $v_1$.
Hence, if there is a multiple conflicting changes in a control flow graph, then we can treat them as a single affected region. 

% We note that although the example above is for a single change, a similar method can be applied for multiple changes in the control flow graph. 

\subsection{Node Listing as Affected Region}
A \textit{node listing}~\cite{node_listing} for control flow graph \textit{G=(N,E,n$_0$)}, where \textit{N} is the set of nodes, \textit{E} is the set of edges, and \textit{n$_0$} is the
program entry nodes, is defined to be a sequence 
\begin{equation}
 l=(n_1, n_2, ......n_m)
\end{equation}
of nodes from \textit{N}(nodes may be repeated) such that every single path in \textit{G} is a subsequence of \textit{l}. 

We can use \textit{node listing} as an affected region without traversing the control flow graph.
But \textit{node listing} may include some unaffected nodes which leads to redundant computation.   

Consider an example shown in figure~\ref{fig:node_listing}. The node listing for this graph is \textit{l=(1, 2, 3, 4, 5, 4, 5, 6)}.
Suppose, expression $b=1$ is present at node 4. Due to a program change if expression $a*b$ is inserted at node 1 then we can use list `\textit{l}' as an affected region without traversing the control flow 
graph. Due to the presence of expression $b=1$ at node 4, the nodes 5 and 6 is not affected by this change. But node listing method will include nodes 5 and 6
also which leads to redundant computation. Our method of creating an affected region will exclude node 5 and 6.

\begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,10)(100,90)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{50}{80}{%
	      \pscirclebox{1}}
\putnode{n2}{n1}{-13}{-15}{%
	      \pscirclebox{2}}
\putnode{n3}{n1}{13}{-15}{%
	      \pscirclebox{3}}
\putnode{n4}{n2}{13}{-15}{%
	      \pscirclebox{4}}
\putnode{a}{n4}{-8}{0}{$b=1$}
\putnode{n5}{n4}{0}{-15}{%
	      \pscirclebox{5}}
\putnode{n6}{n5}{0}{-15}{%
	      \pscirclebox{6}}

\ncline{->}{n1}{n2}
\ncline{->}{n1}{n3}
\ncline{->}{n2}{n4}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\nccurve[angleA=300,angleB=60,ncurv=2]{->}{n5}{n4}
\end{pspicture}
\caption[Node listing as affected region]{Control flow graph for \textit{node listing}}
   \label{fig:node_listing}
\end{figure}






\subsection{Handling Structural Changes}
The following two kinds of changes may take place:
\begin{itemize}
 \item Changes in the lattice. \newline
 If there is a change in a lattice element, i.e. adding a new expression in the program or removing all computations of an 
 expression from the program. Such a change needs to be processed using an exhaustive analysis.
 \item Changes in the graph. \newline
 Consider an edge $e = (i,j)$. Let u $\equiv$ OUT$_i$ and v $\equiv$ IN$_j$,
 two flow functions $h(u,v)$ and $h'(v,u)$ are associated with an edge e.
 \begin{itemize}
  \item Deletion of an edge: \newline
  Deleting an edge $e$ will delete functions $h(u,v)$ and $h'(v,u)$. We know that a non-existant function is a constant function $\top$. Thus, some functions
  may change to $\top$ which is a bottom to top change.
  \item Insertion of an edge:\newline
  Inserting an edge $e$ will add two new functions $h(u,v)$ and $h'(v,u)$ which is a top to bottom change.
  \item Deletion of a node: \newline
  Deletion of a node involves both top to bottom and bottom to top changes as illustrated in figure \ref{fig:delnodexample}.
  The deletion of the node $k$ starts with the removal of edges $e1 = (i, k)$ and $e2 = (k, j)$, a bottom to top change. 
  This is followed by addition of the edge $e3 = (i, j)$, a top to bottom change.

  \begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(35, 45)(65, 85)
%\psframe(35, 45)(65, 85)
\putnode{n1}{origin}{50}{80}{%
	       \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
	       \rput(40,80){\rnode{a}{$i$}}
% 	       \rput(45, 75){\rnode{a}{$u$}}
% 	       \rput(45, 70){\rnode{a}{$k_1$}}
% 	       \rput(45, 60){\rnode{a}{$k_2$}}
% 	       \rput(45, 55){\rnode{a}{$v$}}
\putnode{n2}{n1}{0}{-15}{%
	       \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
	        \rput(40,65){\rnode{b}{$k$}}
\putnode{n3}{n2}{0}{-15}{%
	       \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
		\rput(40,50){\rnode{c}{$j$}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\nccurve[angleA=330,angleB=30,ncurv=0.75,linestyle=dotted, linecolor = red, linewidth = 0.6]{->}{n1}{n3}

\end{pspicture}
\caption{Deletion of a Node}
   \label{fig:delnodexample}
\end{figure}

  
  
  \item Insertion of a node:\\
  The process of insertion of a node is complementary to the deletion process explained above. 
  The insertion process, as illustrated in figure \ref{fig:insnodexample}, starts with 
  deletion of the edge $e1 = (i, j)$, a bottom to top change. This is followed by insertion of edges $e2 = (i, k)$  and $e3 = (k, j)$, a top to bottom change.
  
  \begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(35, 45)(65, 85)
%\psframe(35, 45)(65, 85)
\putnode{n1}{origin}{50}{80}{%
	       \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
	       \rput(40,80){\rnode{a}{$i$}}
% 	       \rput(45, 75){\rnode{a}{$u$}}
% 	       \rput(45, 70){\rnode{a}{$k_1$}}
% 	       \rput(45, 60){\rnode{a}{$k_2$}}
% 	       \rput(45, 55){\rnode{a}{$v$}}
\putnode{n2}{n1}{0}{-15}{%
	       \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
	        \rput(40,65){\rnode{b}{$k$}}
\putnode{n3}{n2}{0}{-15}{%
	       \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
		\rput(40,50){\rnode{c}{$j$}}

\ncline[linestyle=dotted, linecolor = red, linewidth = 0.6]{->}{n1}{n2}
\ncline[linestyle=dotted, linecolor = red, linewidth = 0.6]{->}{n2}{n3}
\nccurve[angleA=330,angleB=30,ncurv=0.75]{->}{n1}{n3}

\end{pspicture}
\caption{Insertion of a Node}
   \label{fig:insnodexample}
\end{figure}

 \end{itemize}

\end{itemize}
\begin{comment}
Control flow graph will change due to the following:
\begin{itemize}
 \item Adding a node
 \item Deleting a node
 \item Adding an edge
 \item Deleting an edge
 \end{itemize}
 \end{comment}
 
%  For adding a node/edge, we need not create an affected region since the effect of adding a node/edge will always go down the graph.
%  Otherwise, we need to create an affected region.

\subsection{Validation}
We can validate the results of incremental analysis by comparing it with the result of exhaustive analysis. 


\subsection{Complexity}
Let $n$ be the total number of nodes in the graph and $m$ be the total number of nodes in the affected region.
The worst case time complexity to identify the boundary nodes is \textit{O(m)} since each node in an affected region needs
to be checked.
We note that in the extreme case, $m = n$.

\section{Other Approaches of Incremental Data Flow Analysis}
One approach~\cite{inc1} is based on Context Free Language(CFG) reachability for incremental analysis of context-sensitive points-to analysis. It traces the CFL-reachable
paths which was traversed during computation of points-to sets to precisely identify and recompute the affected points-to sets when the program changes made. 

Another approach~\cite{inc2}, generates a structural difference between the old and new code version, called as \textit{diff}. The \textit{diff} 
provides an information of added and removed nodes/edges from the inter-procedural control-flow graph(ICFG). Added or removed nodes are called as
\textit{changed} nodes. The set of \textit{affected} node contains all the nodes which are reachable from the \textit{changed} nodes(which is an over approximation). The set of \textit{affected} nodes are inferred from the set of \textit{changed} node. 
This is followed by a clear-and-propagate strategy: for each affected node, it clears the  computed information
and then re-propagates the information from all the node’s predecessors. Basically, it creates an affected region for all kind of changes.

\section{Summary}
When a program undergoes changes, data flow values computed earlier become invalid. Updating the data flow information to incorporate the effect
of changes by repeating an exhaustive analysis can be cost inefficient since it may compute redundant values. In such cases, incremental data flow
analysis, which modifies only the data flow information of the program that has been affected by the change is more cost effective.

In bit-vector frameworks, due to program change the data flow value may change either from top to bottom or vice versa. Top to bottom change can
be incorporated by directly propagating the values to the neighbors of the changed node. For bottom to top change, we need to create an affected 
region to incorporate the change to the neighbors of the changed node.

% In constant propagation, the IN information of a changed node may depend on the OUT information. Thus, we cannot directly propagate
% the IN information to its neighboring nodes without attracting the possibility of dispersing incorrect information. In such cases, we need to create an affected region.


\begin{comment} 
As shown in figure~\ref{fig:detecting_loop}, definition of $b$ at the changed node is
reaching to IN of that node itself. Hence, there is a path from changed node to itself. So we need to create an affected region to propagate the change to its neighbouring 
nodes.
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{An Overview of PRISM}
PRISM is a program analyzer generator developed bt TATA Research Development and Design Center(TRDDC).
This chapter contains an overview of the architecture of PRISM analyzer generator.

% \section{Architecture of PRISM}
PRISM has the following two basic components:
\begin{itemize}
 \item Kulang compiler: Kulang compiler parses analyzer specifications and generates some java classes.
 \item Solver : These classes are used by solver to solve data flow problems. It also uses many other packages which provide many utility functions. These functions are used 
 my the solver.
\end{itemize}

\section{PRISM IR}
The program to be analyzed is compiled using a front end IR generator. It generates a language independent intermediate representation of the program. Unlike intermediate
language of typical compiler, IR is a high level language and contains complex expressions. Different front end translators are used for different languages which converts
the language to the PRISM IR.

Figure~\ref{fig:Architectur_prism1}~\cite{thesis_v} shows a block diagram of various PRISM components. IR generator generates independent intermediate representation of the program to be 
analyzed. The generated analyzer takes IR as an input and produces output reports.

\begin{figure}[t]
\centering
\psset{unit=1mm}
\begin{pspicture}(-20,15)(115,90)

\begin{psframe}(-20,15)(115,90)
\putnode{n1}{origin}{75}{80}{%
	  {\textbf{Program}}
     }

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{IR Generator}}

\putnode{n3}{n2}{0}{-10}{%
     {\textbf{Generated IR}}}

\putnode{n4}{n3}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{Solver}}

\putnode{n5}{n4}{30}{0}{{\textbf{Results}}}

\putnode{n6}{n4}{-55}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{Kulang Compiler}}

% \putnode{n8}{n6}{0}{15}{%
%      {Copied}}
% \rput(55,33){\rnode{a}{Generated}}
\putnode{n7}{n6}{-30}{0}{%
      {\textbf{.klg files}}}

\putnode{n8}{n6}{5}{15}{%
     \psframebox[linewidth=.3,framesep=1.7]{Other Utility functions}}
\putnode{n9}{n7}{64}{-6}{%
     {Generated Java files}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n6}{n4}
\ncline{->}{n7}{n6}
% \nccurve[angleA=0, angleB=100, ncurv=0.5]{->}{n7}{n6}
\ncline{->}{n8}{n4}
\end{psframe}

\end{pspicture}
\caption{Architecture of PRISM}
    \label{fig:Architectur_prism1}
\end{figure}




% \begin{figure}[H]
% \centering
% \psset{unit=1mm}
% \begin{pspicture}(-20,15)(100,80)
% \psframe(-35,15)(115,80)
% \putnode{n1}{origin}{60}{70}{%
% 	  {\textbf{Program}}
%      }
% 
% \putnode{n2}{n1}{0}{-15}{%
%      \psframebox[linewidth=.3,framesep=1.7]{IR Generator}}
% 
% \putnode{n3}{n2}{0}{-10}{%
%      {\textbf{Generated IR}}}
% 
% \putnode{n4}{n3}{0}{-15}{%
%      \psframebox[linewidth=.3,framesep=1.7]{Generated analyzer}}
% 
% \putnode{n5}{n4}{40}{0}{{\textbf{Results}}}
% 
% \putnode{n6}{n4}{-55}{0}{%
%      \psframebox[linewidth=.3,framesep=1.7]{Kulang Compiler}}
% 
% \putnode{n8}{n6}{0}{15}{%
%      {Copied}}
% % \rput(55,33){\rnode{a}{Generated}}
% \putnode{n7}{n6}{-30}{0}{%
%       {\textbf{.klg files}}}
% 
% \putnode{n8}{n6}{-30}{10}{%
%     {\textbf{.java files}}}
% \putnode{n9}{n7}{56}{-3}{%
%      {Generated}}
% 
% \ncline{->}{n1}{n2}
% \ncline{->}{n2}{n3}
% \ncline{->}{n3}{n4}
% \ncline{->}{n4}{n5}
% \ncline{->}{n6}{n4}
% \ncline{->}{n7}{n6}
% % \nccurve[angleA=0, angleB=100, ncurv=0.5]{->}{n7}{n6}
% \nccurve[angleA=10, angleB=150, ncurv=0.4]{->}{n8}{n4}
%      
% \end{pspicture}
% \caption[Architecture of PRISM]{Architecture of PRISM}
%    \label{fig:Architectur_prism1}
% \end{figure}



\subsubsection{Accessing statements in PRISM IR}
Each function in the program is represented by an \texttt{IRObject}. Each \texttt{IRObject} is associated with an instance of \texttt{ICFG} (represents control flow graph of that function).
An \texttt{ICFG} contains a list of \texttt{ICFGnodes} which represents one statement in a program. It also contains a pointer to the entry \texttt{ICFGnode} of that function.
Each \texttt{ICFGnodes} stores a list of its successor and predecessor. Between two \texttt{ICFGnodes}, there is an \texttt{ICFGEdge} which can be either data flow or
control flow edge. An array of \texttt{IRObjects}, representing all functions in a program, is provided by PRISM API. If an \texttt{ICFGnode} represents a
function call, an API over it can be used to get \texttt{ICFG} of the function that is called.

\subsubsection{Interpreting statements in PRISM IR}
Each \texttt{ICFGNode} represents a statement in PRISM IR. The \texttt{ICFGNode} is associated with an instance of \texttt{Expr} which represents the expression of the 
statement. \texttt{Expr} is a base type and can be many of its subtypes. Some possible subtypes are: 
\begin{itemize}
 \item Unary
 \item Binary
 \item Call
 \item Return Statement
\end{itemize}


An expression is composed of a tree structure of operands and operators. Each expression type has API function to access operators and operands. 
A variable in an expression is represented using an instance of \texttt{NamedEntity}. A \texttt{NamedEntity} cantains various properties of the variable, such as name, 
scope, data type etc. Various API functions are available to determine the type of the \texttt{NamedEntity}, such as pointer, static etc. Unlike variables, 
\texttt{NamedEntity} can have expression like structure. Following are the types of \texttt{NamedEntities}:
\begin{itemize}
 \item \texttt{STNamedEntity} : ST stands for Symbol Table. It returns variables used in the program.
 
 e.g. In the expression ``\texttt{a=b+c}'', a, b and c are of type \texttt{STNamedEntity}
 
 \item \texttt{PSTNamedEntity} : A part of  \texttt{STNamedEntity} is represented by \texttt{PSTNamedEntity}
 
  e.g. In the expression ``\texttt{x.y=a[0]}'', \texttt{a.b} is a \texttt{PSTNamedEntity} which is a part of \texttt{STNamedEntity} \texttt{a}
 
 \item \texttt{IndirectNamedEntity} : \texttt{NamedEntity} to represent dereference. 
 
 e.g. In the expression ``\texttt{int *p}'', \texttt{*p} is a \texttt{IndirectNamedEntity}. 
 
 \item \texttt{PIndirectNamedEntity} : A part of another \texttt{IndirectNamedEntity} is represented by \texttt{PIndirectNamedEntity}. In the following example $x \rightarrow y$ is a part 
 of \texttt{IndirectNamedEntity} which is represented by \texttt{PIndirectNamedEntity}
 
e.g. \texttt{x $\rightarrow$ y= a[0]}
 
 
 \item \texttt{HeapNamedEntity} : During dynamic allocation \texttt{HeapNamedEntity} is created. Each heap location is assigned a unique number according to the line number where
 \texttt{malloc} or \texttt{calloc}  is used. 
 
e.g. \texttt{p =(float *) malloc(sizeof(float));}
 
 
 \item \texttt{PHeapNamedEntity} : A part of \texttt{HeapNamedEntity} is represented by \texttt{PHeapNamedEntity}. In the following example $p \rightarrow q$ represents a part of \texttt{HeapNamedEntity}
 
e.g. \texttt{p = (float *) malloc(sizeof(float));}

\hspace{8mm}\texttt{p $\rightarrow$ q  = a[0] ;}

\item \texttt{EnumlitNamedEntity} : \texttt{NamedEntity} to represents a value of enum type

\item \texttt{AddressNamedEntity} : An address data item is represented by \texttt{AddressNamedEntity}. In the following example \&b represents an \texttt{AddressNamedEntity}

e.g. \texttt{a = \&b;}

\item \texttt{SizeofNamedEntity} : It represents use of sizeof operator

\item \texttt{StructNamedEntity} : String literal is represented by \texttt{StructNamedEntity}. In the following example ``Hello world'' is a \texttt{StructNamedEntity}

e.g. \texttt{string c* =``Hello world'';}

\item \texttt{LabelNamedEntity} : A label in a program is represented by \texttt{LabelNamedEntity}. In the following goto statement, a \texttt{LabelNamedEntity} is created for the label begin

e.g. \texttt{goto begin;}


\item \texttt{ArrayindexNamedEntity} : An expression where an array is indexed is represented by \texttt{ArrayindexNamedEntity}. In the following example a[0] is a 
\texttt{ArrayindexNamedEntity}

e.g. \texttt{q = a[0];}

\item \texttt{NullNamedEntity} : If a pointer is made to point to address 0 then it is represented by \texttt{NullNamedEntity}
\item \texttt{FunctionnameNamedEntity} : A function name is represented by \texttt{FunctionnameNamedEntity}
\item \texttt{UndefinedNamedEntity} : If a variable is undefined then the value represented by that variable is \texttt{UndefinedNamedEntity}

 %%copy from vinit's report
 
 
\end{itemize}


\section{Structure of analyser generator}
An analyser writer needs to write two following components:
\begin{itemize}
 \item Kulang specifications~\cite{prism}
 \item Data flow analysis API class
\end{itemize}


\subsection{Kulang specifications}
While analyzing a program, Intraprocedural Control Flow Graph (ICFG) is created for each function. For each function in ICFG, GEN and KILL summary is computed.
The specification for computing GEN and KILL summary is specified using Kulang query files. A kulang query file has ``\textbf{.klg}'' extension.
The query file consists of a Kulang query to be solved. The file is organized in the following way:
\begin{itemize}
 \item Package declaration : This is the first line in the kulang file. It tells the Kulang compiler to put the generated Java files into the specified package, for
 all the queries written in the file.

 Syntax :
 
\hspace{15mm}\textit{package identifier}

\hspace{15mm} For e.g. \texttt{package darpan.klgLib;}

\item Typedef :\newline 
Syntax : 

\hspace{15mm}\textit{TypeName::Type}

\hspace{15mm}For e.g. \texttt{tup::tuple(int,NamedEntity);}

\item Use declaration : The ``use'' declaration is used when the user wants to use/call other Kulang queries from other packages.
It is similar to ``\texttt{import}'' statement in java. There are two following types:
	\begin{itemize}
	\item \texttt{fun\_use} : This defines the path from where the query generated Java files should be accessed
			  \newline Syntax : 
			  
					    \hspace{15mm} \textit{fn\_use identifier;}
					    
					    \hspace{15mm} For e.g. \texttt{fn\_use darpan.klgLib;}
	\item \texttt{java\_use} : It specifies the class file where Java files accessed in this query are present. It is followed by \texttt{java$\_$decl}, which specifies the Java functions used from the file specified in \texttt{java\_use}
	 \newline Syntax : 
			  
					    \hspace{15mm} \textit{java\_use identifier;}
						    
					    \hspace{15mm} \textit{java\_decl} 

					    \hspace{15mm} \textit{type function ;}

					    \hspace{15mm} For e.g. \texttt{java\_use darpan.klgLib.Aux;}
					    
					    \hspace{31mm}\texttt{java\_decl}
					    
    					    \hspace{30mm} \texttt{int print\_set(set NameEntity);}

	\end{itemize}

	
\item Mode : Mode is defined as follow. FLA stands for Function Level Analysis.

 Syntax : 
			  
		\hspace{15mm} \texttt{[FLA];}
		
\item Lattice Type : Type of the elements in lattice. Two following types are possible:

\begin{itemize}
	\item Forward lattice : Used in forward analysis
			  \newline Syntax : 
			  
					    \hspace{15mm} \textit{Forwardlattice IDENT::typedef;}
					    
					    \hspace{15mm} For e.g. \texttt{Forwardlattice L::tup;}
	\item Backward lattice : Used in backward analysis
	 \newline Syntax : 
			  
					    \hspace{15mm} \textit{Backwardlattice IDENT::typedef;}
						    
					    \hspace{15mm} For e.g. \texttt{Backwardlattice L::tup;}

					   
	
\end{itemize}

\item  Top : Top of the lattice for data flow analysis. Type of the Expr should be compatible with the type of lattice element given in the Lattice Specification. Following are the types
\begin{itemize}
	\item Forward top : top of forwardlattice
			  \newline Syntax : 
			  
					    \hspace{15mm} \textit{ForwardTop::Expr;}
					    
					    \hspace{15mm} For e.g. \texttt{ForwardTop::(tup){};}
	\item Backward top : top of backwardlattice
	 \newline Syntax : 
			  
					    \hspace{15mm} \textit{BackwardTop::Expr;}
						    
					    \hspace{15mm} For e.g. \texttt{BackwardTop::(tup){};}

					   
\end{itemize}

\item Meet : specifies the meet operation to be performed at the merge of two paths. Following are the types:
\begin{itemize}
	\item Forward meet : meet operation for forward analysis
			  \newline Syntax : 
			  
					    \hspace{15mm} \textit{IDENT ForwardMeet IDENT : Expr;}
					    
					    \hspace{15mm} For e.g. \texttt{A ForwardMeet B : A+B;}
	\item Backward meet : meet operation for backward analysis
	 \newline Syntax : 
			  
					    \hspace{15mm} \textit{IDENT BackwardMeet IDENT : Expr;}
					    
					    \hspace{15mm} For e.g. \texttt{A BackardMeet B : A+B;}

					   
\end{itemize}

\item Boundary values : It gives the starting value to solve the Data Flow problem.The
Program Entry ( in case of a Forward Problem ) / Program Exit ( in case of a Backward
Problem ) node will be initialized with this value.
\begin{itemize}
	\item Forward boundary value : boundary value for forward analysis
			  \newline Syntax : 
			  
					    \hspace{15mm} \textit{ForwardBoundaryValue : Expr;}
					    
					    \hspace{15mm} For e.g. \texttt{ForwardBoundaryValue :(tup){};}
	\item Backward boundary value : boundary value for backward analysis
	 \newline Syntax : 
			  
					    \hspace{15mm} \textit{BackwardBoundaryValue : Expr;}
					    
					    \hspace{15mm} For e.g. \texttt{BackwardBoundaryValue :(tup){};}

					   
\end{itemize}

\item Flow functions : It defines how data flow value changes when it passes through a node or edge. The specific node or edge is available to the function as a parameter.
Four types of flow function exits - \texttt{ForwardNodeflow}, \texttt{BackwardNodeFlow}, \texttt{ForwardEdgeFlow} and \texttt{BackwardEdgeFlow}
\newline Syntax for flow functions:
\begin{itemize}
 \item 
%  \begin{lstlisting}[]  % Start your code-block

\textit{Forward/BackwardNodeflow(IDENT:nodeType, IDENT:LatticeType)}

\textit{let}

\hspace{10mm} \textit{Expressions;}

\textit{in}

\hspace{10mm}\textit{Return variable;}
% \end{lstlisting}
 
\ item
%  \begin{lstlisting}[]  % Start your code-block

\textit{Forward/BackwardEdgeflow(IDENT:nodeType, IDENT:LatticeType)}

\textit{let}

\hspace{10mm}\textit{Expressions;}

\textit{in}

\hspace{10mm}\textit{Return variable;}
% \end{lstlisting}
  
\end{itemize}

\end{itemize}

\subsubsection{Kulang Constructs}
\begin{itemize}
 \item Types : It supports standard data types such as int, char, string etc, IR model types and JAVA methods that operate over those types.
 Type casting is also supported in kulang specifications.
 
 \item Constants : PRISM allows usual constants for standard types,such as  NULL, true, 1, ‘a’ etc.
 \item Expressions : Expressions are bound to identifiers. Contional expressions are also allowed.
 
 For e.g.
 \begin{lstlisting}[]  % Start your code-block
   
   x=if(condition)
     then
	  expression1
     else
	  expression2
     endif;
 
\end{lstlisting}

\item Tuples : It is collection of data items of same or different data types.

For e.g.
 \hspace{15mm} \texttt{Tuple=[Expr1,Expr2];}
 
\item Set : It is a collection of data items of same data type.

For e.g.
 \hspace{15mm} \texttt{Set=\{a,b\};}				    

 \item Iterations : Consider an example as shown below, x takes each element in S and check for the condition after \textbf{`\textbar'}.
 If it satisfies the condition then that element is returned and store it in \texttt{newSet}. 
 
 For e.g.
 \hspace{15mm} \texttt{newSet = \{x$\leftarrow$S\hspace{1mm} \textbar \hspace{1mm} condition \};}
 
 \item Accumulation : Consider an example as shown below, \textbf{a} is an accumulator which is initialized to an empty set. \textbf{`x'}
 takes each element in \textbf{`S'}. Operation is performed on \textbf{`x'} and then the result is added to the accumulator.
 
 For e.g.
 
  \texttt{newSet= <<a :(set NamedEntity)\{\}; x$\leftarrow$A; a+\{operation\}>>;}
\end{itemize}



 
 
\subsection{Data flow analysis API class}
This class contains functions to invoke the execution of the analysis. It also provides an API to get results of the analysis. It can be
accessed by user to get data flow values at some program point. It can also be use while solving a data flow problem dependent on the implemented
data flow problem. 

Figure~\ref{fig:generated_analyser} shows an architecture of generated analyzer. The solver takes data flow analysis API class, functions generated by kulang compiler and some utility functions provided
by PRISM as input and generates a result.
\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(-20,10)(105,80)
\psframe(-20,10)(105,80)

\putnode{n2}{origin}{45}{30}{%
     \psframebox[linewidth=.3,framesep=5.7]{Solver}}
\putnode{n1}{n2}{-40}{0}{%
     \textbf{Generated IR}}


 \putnode{n3}{n2}{40}{0}{%
      \textbf{Result}}

 \putnode{n4}{n2}{-40}{30}{%
      \psframebox[linewidth=.3,framesep=1.7]{\begin{tabular}{c}
                                             Generated \\
                                             file	s by \\
                                             kulang compiler
                                             \end{tabular}
}}

 \putnode{n5}{n2}{0}{30}{%
      \psframebox[linewidth=.3,framesep=1.7]{Utility functions}}
 
\putnode{n6}{n2}{40}{30}{%
      \psframebox[linewidth=.3,framesep=1.7]{\begin{tabular}{c}
                                             Data flow \\
                                             analysis API
                                             \end{tabular}
}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n4}{n2}
\ncline{->}{n5}{n2}
\ncline{->}{n6}{n2}  
\end{pspicture}
\caption[Block diagram of solver]{Architecture of analyzer generator}
   \label{fig:generated_analyser}
\end{figure}


\subsection{Running the generated analyser}
The steps for configuring and running the analyzer are given in the Appendix~\ref{ap:A}.

\section{Bi-directional Solver}
In this section, we describe the Bi-directional~\cite{thesis_v} solver, its modules and its limitations.
The Kulang, a specification language, is used to specify the data flow analysis in PRISM. The bi-directional Kulang compiler parses the specifications
and generates java classes. The Bi-directional Solver invokes the generated java classes to solve the data flow problem.

Following are generated .java files:
\begin{itemize}
 \item \texttt{kulang$<$queryname$>$FG$\_$Flow.java}: It contains \textit{forward and backward} flow and inter-procedural edge functions.  
 \item \texttt{kulang$<$queryname$>$FG$\_$Meet.java}: It contains \textit{forward and backward} meet functions.
 \item \texttt{kulang$<$queryname$>$FG$\_$Adapter.java}: It provides an interface to create an instance of the query. 
 \item \texttt{kulang$<$queryname$>$FG$\_$ModelPopulator.java}: It populates the model.
\end{itemize}


\subsection{Modules of Bi-directional Solver}
Following modules are used in the bi-directional Solver.
\begin{itemize}
 \item \textbf{DFStore:} It stores context sensitive data flow information. It also provides an API to access the data.
 \item \textbf{ValueContexts:} It stores information about contexts formed during analysis.
 \item \textbf{ContextTransition:} It stores context transition graph which is a method of representing call strings.
 \item \textbf{DFSolverLogger:} This module provides utilities for logging, measuring performance parameters of the core solver.
 \item \textbf{InterproceduralWorklist:} This module manages work list and applies a priority scheme to the work list.
\end{itemize}

More details about these modules are presented in the Appendix~\ref{ap:BidirectionalSolver}

\subsection{Limitations of Bi-directional Solver}
Following are some of the limitations of the Bi-directional solver:
\begin{itemize}
 \item It does not support Incremental data flow analysis.
 \item It outputs the results in a text file. 
 \item Meet function needs to be explicitly specified in kulang specifications. The meet function can be inferred from
the lattice of the data flow problem.
 \item There is no proper way to debug the kulang specifications.
 \item The specification language is not very intuitive and has a steep learning curve.
\end{itemize}





\begin{comment}
\subsection{Limitations in current version of PRISM}
This section describes some imitations in current version of PRISM. Some of which we are trying to overcome in our implementation.
Following are some of the limitations :
\begin{itemize}
 \item It does not support Incremental data flow analysis
 \item Meet function needs to be explicitly specified in kulang specifications or defined as a java function. The meet function can be inferred from
the lattice of the data flow problem
\item There is no proper way to debug the kulang specifications
 \item Very hard to understand the specification language
\end{itemize}
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Liveness Based Reaching Definition Analysis using PRISM}

In order to understand PRISM, we have implemented a query for Liveness-based reaching definition analysis using PRISM. Other queries which are 
implemented using PRISM are Liveness analysis, Strongly Liveness analysis, Liveness analysis with aliasing and Strong liveness analysis with aliasing.
Full specifications of Reaching definition with and without liveness extended to inter-procedural level are given in Appendix~\ref{ap:C}. This section describes flow functions for reaching definition analysis with and without
liveness.

\section{Reaching definition analysis}
This section describes the flow functions for Intra-procedural reaching definition analysis.
The Data flow equations for Reaching Definition analysis is shown below:

\begin{equation}
\begin{split}
\mbox{\textit{In}}_n &= \left\{ \begin{array}{ll}
	  \mbox{\textit{BI}} & \mbox{n is Start block}\\
	  \bigcup\limits_{p \in pred(n)} Out_p & \mbox{otherwise}
	  \end{array} \right.\\ 
\mbox{\textit{Out}}_n &= \mbox{\textit{Gen}}_n \cup (\mbox{\textit{In}}_n - \mbox{\textit{Kill}}_n) \\
\mbox{\textit{BI}} &= \{d_x : x = \mbox{\textit{undef}} \mid x \in \mbox{\textit{Var}}\} \\
\end{split} 
\end{equation}
  
Flow function for binary statements is shown below. Here, we are checking statements having `$=$' as an operator, otherwise we  
directly propagates the values at the IN of that node. First we find the NE present in the expression (line no.4-6). `\texttt{line}'
 function at line 7, returns the line number of the statement. `\texttt{kill}' set at line 8 contains the set of elements that need 
 to be removed from the set of data flow values reaching at that node. `\texttt{HasElement}' is a function(as shown below) defined in
`\textbf{Aux.java}' file, it takes \texttt{NamedEntity} and set of tuples as a parameter, and returns a set of tuples whose \texttt{NamedEntity} is same
as that of the \texttt{NamedEntity} present in the \texttt{lhs} of the statement. `\texttt{def}' set contains the definition defined at that node.

\begin{lstlisting}[]  % Start your code-block

1. ForwardNodeflow( n: Binary, S: L )
2.     if(operator(n) == '=') then   
3.        let        
4.                rt_expr = rhs(n);
5.                l_exp = lhs(n);
6.                ne = NE(n);
7.                line_no = line(l_exp);
8.                kill = HasElement(ne,S); 
9.                def = {[line_no,ne]};
10.       in
11.       	  (S-kill)+def        
12.       else
13.        	  S
14.       endif;
\end{lstlisting}

Following is a code for \texttt{unary} statements. Similarly, it will generate a `\texttt{kill}' set by using a function `\texttt{HasElement}' 
. \texttt{def} contains a definition defined at that node. Statement \texttt{`(S-kill)+def'}, will calculate the values at the OUT of that
node.
\begin{lstlisting}[]
15. ForwardNodeflow( n: Unary, S: L )
16.	let
17.		ne = NE(n);
18.		line_no = line(n);
19.		kill = HasElement(ne,S);
20.		def = {[line_no,ne]};
21.	in
22.		(S-kill)+def;
\end{lstlisting}

For other types of statements, it will just propagates the values reaching at the IN of that node to its OUT. Following in the code.

\begin{lstlisting}[]
23. ForwardNodeflow( n: _, S: L ) 
24.	S;
\end{lstlisting}

Java code for function `\texttt{HasElement}' is shown below :
\begin{lstlisting}
1. static Set HasElement(NamedEntity ne , Set info_in)
2. {
3.	int no_ele;
4.	Set ret= new HashSet();
5.	no_ele=info_in.nElems();
6.	Enumeration en=info_in.Enumerate();
7.	while(en.hasMoreElements())
8.	{
9.		Tuple t=(Tuple)en.nextElement();
10.		if(t.AtIndex(1).equals(ne))
11.			ret.insert(t);
12.	}	
13.
14.	return ret;
15. }

\end{lstlisting}

\section{Liveness-Based Reaching Definition Analysis}
This section describes the flow functions for Liveness-Based Inter-procedural reaching definition analysis. This is a bi-directional
analysis and hence flow function will take two lattices \texttt{R} and \texttt{L} as a parameter. Lattice \texttt{R} is for reaching definition analysis and
\texttt{L} is for strongly liveness analysis. In first phase, it will do strongly liveness analysis which is a backward flow analysis.
Data flow equations for liveness-Based reaching definition analysis in shown below. The reaching definition sets (\textit{RIn}$_n$ and \textit{ROut}$_n$) are restricted 
to liveness set (\textit{LIn}$_n$ and \textit{LOut}$_n$)

\begin{equation}
\begin{split}
\mbox{\textit{LIn}}_n &= f_n(\mbox{\textit{Out}}_n) \\
\mbox{\textit{LOut}}_n &= \left\{ \begin{array}{ll}
	  BI & \mbox{n is End}\\
	  \bigcup\limits_{s \in succ(n)} In_s & \mbox{otherwise}
	  \end{array} \right.\\ 
\mbox{where,}\\
f_n(X) &= \left\{ \begin{array}{ll}
	  (X-\{y\})\cup(\mbox{\textit{Opd(e)}}\cap \mbox{\textit{Var}}) & \mbox{n is y = e, e $\in$ Expr, y $\in$ X}\\
	  X-{y} & \mbox{n is input(y)}\\
	  X \cup {y} & \mbox{n is use(y)} \\
	  X & \mbox{otherwise}
	  \end{array} \right.\\ 
\\
\mbox{\textit{RIn}}_n &= \left\{ \begin{array}{ll}
	  \mbox{\textit{RBI}} & \mbox{n is Start block}\\
	  \bigcup\limits_{p \in pred(n)}Out_p\mid_{LIn_n} & \mbox{otherwise}
	  \end{array} \right.\\ 
	  \\
\mbox{\textit{ROut}}_n &= \mbox{\textit{Gen}}_n \cup (\mbox{\textit{In}}_n - \mbox{\textit{Kill}}_n) \mid_{LOut_n} \\
\\
\mbox{\textit{RBI}} &= \{d_x : x = \mbox{\textit{undef}} \mid x \in \mbox{\textit{Var}}\} \\	  
\end{split} 
\end{equation}


Flow function for \texttt{binary} statements is shown below. The set `\texttt{rNE}' at line 6, contains \texttt{NamedEntity} in rhs of the statement and `\texttt{lNE}' at line 7, contains
\texttt{NamedEntity} in lhs of the statement. At line 8, if the statement contains ``$=$'' operator and variable in lhs is present at the OUT of node, then we will add
all the variables used and remove the defined variable in the statement from the set `\texttt{x}'. Otherwise, we will add all the used variables in the set
`\texttt{x}'.

\begin{lstlisting}

1. BackwardNodeflow( n: Binary, R: rec, L: Liv )
2.        let
3.                
4.                rt_expr=rhs(n);
5.                lt_expr=lhs(n);
6.                rNE=getNEs(rt_expr);
7.                lNE=getNEs(lt_expr);
8.                x = if(operator(n)=='=')
9.                        then
10.                                if(isLive(lt_expr,L)==true)
11.                                        then
12.                                                (L - lNE) + rNE
13.                                        else
14.                                                L
15.                                endif
16.                        else
17.                                ( L + lNE ) + rNE
18.	                   endif;
19.        in
20.                x;

\end{lstlisting}


Flow function for \texttt{unary} statements is given below. At line 23, \texttt{operands\_ne} contains the \texttt{NamedEntities} of all the variables used in the 
statement. At line 25, variables which are used in the statement are added to the Liveness set `L'.

\begin{lstlisting}
21. BackwardNodeflow( n: Unary, R: rec, L: Liv )
22.        let
23.                operands_ne=getNEs(n);
24.        in
25.                L+operands_ne;

\end{lstlisting}

Flow function for \texttt{Call} statements is given below. At line 29, \texttt{UseInCall} contains \texttt{NamedEntities} of all the variables present in call
statement. At line 31, the used variables are added to the Liveness set.

\begin{lstlisting}
26. BackwardNodeflow( n: Call, R: rec, L: Liv )
27.        let
28.                d = emptySet();
29.                UseInCall = getNEsFromCall(n);
30.        in
31.                d + L + UseInCall
\end{lstlisting}

Flow function for other types of nodes is shown below.

\begin{lstlisting}
32. BackwardNodeflow( n: _, R: rec, L: Liv)
33.        L;
\end{lstlisting}


After computing liveness set as discussed above, based on that set reaching definition is performed. Here we will compute reaching definition of those
variables which are live at the IN of that node. This is a forward flow analysis.

Flow function for \texttt{binary} statements is shown below. At line 39, \texttt{line\_no} will contain the line number of the statement. At line 40,
\texttt{kill} set will contain \texttt{NamedEntity} of all the values at the IN of node whose \texttt{NamedEntity} is same as that of the variable defined at the statement.
At line 41, \texttt{sur} will contain the computed data flow value at the node. From line 43 to 49, if statement contains ``='' operator then it will 
check whether the value which is defined is live or not, otherwise it will propagate only those values which is live at the IN of that node. Function
\texttt{removeNonLive} checks the liveness of the variable defined at the node. If the variable is live then add the definition to the reaching set.

\begin{lstlisting}
34. ForwardNodeflow( n: Binary, R: rec , L:Live )
35.        let
36.                rt_expr=rhs(n);
37.                l_exp=lhs(n);
38.                ne=NE(n);
39.                line_no=line(l_exp);
40.                kill=HasElement(ne,R);
41.                def={[line_no,ne]};
42.                sur=(R-kill)+def;
43.               survive=if(operator(n)=='=')
44.                        then
45.                                removeNonLive(sur,L)
46.                        else
47.                                removeNonLive(R,L)
48.
49.                        endif;
50.        in
51.                survive;
\end{lstlisting}

Following is the flow function for \textbf{unary} statements. At line 60, after computing the values at the node (55-59), if the variable is live at the IN of the node
then we will add the definition of the variable defined at that not. 

\begin{lstlisting}
52. ForwardNodeflow( n: Unary, R: rec , L:Liv )
53.        let
54.                
55.                ne=NE(n);
56.                line_no=line(n);
57.                kill=HasElement(ne,R);
58.                def={[line_no,ne]};
59.                sur=(R-kill)+def;
60.		  survive=removeNonLive(sur,L);
61.        in
62.               survive;

\end{lstlisting}

Flow function for other types of statements is given below.

\begin{lstlisting}
63. ForwardNodeflow( n: _, R: rec , L:Liv)
64.        let
65.                survive=removeNonLive(R,L);
66.        in
67.                survive;

\end{lstlisting}

Following is the Java code for function `\texttt{isLive}' 
\begin{lstlisting}
1.static boolean isLive(Expr ex,Set s)
2.{
3.      try
4.      {
5.	  Ident_AST iast = (Ident_AST) ex.operands().getAt(0);
6.	  NamedEntity ne = iast.NE();
7.	  if(s == null)
8.		return false;
9.	  if(s.belongs(ne))
10.		return true;
11.	  else
12.		return false;
13.      }
14.      catch(Exception e)
15.      {
16.	  return true;
17.       }
18.}
\end{lstlisting}


\section{SPEC Benchmark Evaluation}
In order to compare the performance between two analysis i.e. reaching definition analysis with and without liveness, we tested both for SPEC Benchmarks.
For each query, we measured the average size of the set of data flow values computed at each program point. In general, average size of the set at each
program point in liveness-based analysis is much smaller then that of the normal reaching definition analysis. However, PRISM solver is not including local
and global declarations as a statement and thus there is a possibility that the results from the benchmark may not concur with the actual numbers.

Performance measurement of reaching definition without liveness is shown in table~\ref{tab:performance_without_l}.
\begin{table}[t]
  \begin{center}
      %\label{tab:Available_exp}
    \begin{tabular}{|c|p{1.5cm}|p{2cm}|p{2cm}|p{2cm}|}
    \hline
%        & \multicolumn{2}{c}{$a+b$} & \multicolumn{2}{c}{$a*b$} & \multicolumn{2}{c}{$a*c$} \\
%     \hline
      Name & No. of Basic Blocks & Avg. values at Entry (in \%) & Avg. values at Exit (in \%) & Total values (in \%)\\
      \hline
%    	\midrule
   	  bzip2 & 8004 & 26.878 & 26.826 & 26.852 \\ \hline
   	  mcf & 1066 & 3.991 & 4.001 & 3.996 \\ \hline
   	  hmmer & 24996 & 2.574 & 2.566  & 2.570 \\ \hline
   	  sjeng & 10892 & 39.219 & 39.245 & 39.232 \\ \hline
   	  h264ref & 42559 & 6.370 & 6.225 & 6.297\\ \hline
   	  lbm & 603 & 6.515 & 6.537 & 6.526\\ \hline
   	  
	\hline
%       \bottomrule 
    \end{tabular}
    \caption{Benchmark results for normal reaching definition analysis.}
      \label{tab:performance_without_l}
  \end{center}
\end{table}



The performance measurement of reaching definition with liveness is shown in table~\ref{tab:performance_with_l}.
\begin{table}[t]
  \begin{center}
      %\label{tab:Available_exp}
    \begin{tabular}{|c|p{1.5cm}|p{2cm}|p{2cm}|p{2cm}|}
    \hline
%        & \multicolumn{2}{c}{$a+b$} & \multicolumn{2}{c}{$a*b$} & \multicolumn{2}{c}{$a*c$} \\
%     \hline
      Name & No. of Basic Blocks & Avg. values at Entry (in \%) & Avg. values at Exit (in \%) & Total values (in \%)\\
      \hline
%    	\midrule
   	  bzip2 & 8004 & 4.852 & 4.570 & 4.711 \\ \hline
   	  mcf & 1066 & 0.724 & 0.666 & 0.695 \\ \hline
   	  hmmer & 24996 & 0.672 & 0.636  & 0.654 \\ \hline
   	  sjeng & 10892 & 3.685 & 3.466 & 3.576 \\ \hline
   	  h264ref & 42559 & 5.321 & 5.197 & 5.259\\ \hline
   	  lbm & 603 & 1.633 & 1.600 & 1.616\\ \hline
   	  
	\hline
%       \bottomrule 
    \end{tabular}
    \caption{Benchmark results for liveness-based reaching definition analysis.}
      \label{tab:performance_with_l}
  \end{center}
\end{table}


Figure~\ref{fig:bench_mark} shows a comparison between two analysis.
\begin{figure}[t]	
\centering
\includegraphics[width=0.8\textwidth]{graph.eps}
\caption{Percentage reduction in size of data set for Reaching definition analysis with and without liveness}
\label{fig:bench_mark}
\end{figure}


\section{Summary}
We have implemented a query for reaching definition analysis with and without liveness using PRISM.
The reaching definition analysis described in this chapter is implemented at intra-procedural level, improved implementation in given in Appendix~\ref{ap:C}.
Other queries which are implemented using PRISM are Liveness analysis, Strongly Liveness analysis, Liveness analysis with aliasing
and Strong liveness analysis with aliasing. 

In order to compare the performance between reaching definition analysis with and without liveness, we tested both for SPEC Benchmarks.
For each query we measured the average size of the set at each program point. It is observed that the average size of the set at each program 
point in liveness-based analysis is much smaller than that of the normal reaching definition analysis with a possibility of the empirical
values deviating from the actual values owing to non inclusion of the local and global statements.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{An Incremental Solver for PRISM}
In this section, we describe implementation of the Incremental Solver. It is divided into the following parts:

\begin{itemize}
\item \textbf{Preprocessing} It reads the two IRs and finds the difference between them.

\item \textbf{Data flow computation}
It consist of following two parts:
\begin{itemize}
 \item \textit{Re-initialization} which constructs the affected region (set of affected node).
 \item  \textit{Re-computation} which identifies boundary nodes and computes the information only for the affected region.
\end{itemize}

\item \textbf{Update} Merges the computed information for the affected region with the old information.
\end{itemize}

Steps for running Incremental Driver is given in Appendix~\ref{ap:A}

\section{Architecture of Incremental Solver}
Figure~\ref{fig:Architectur_incrementalPrism} shows the architecture of the Incremental Solver. The \textit{Preprocessor}
takes \textit{Old IR} and \textit{New IR} as inputs. It compares the two IRs and detects the changed nodes. 
Output of the \textit{Preprocessor} is then passed to the \textit{Re-initializer}. The \textit{Re-initializer} computes 
the affected region, a set of affected nodes, and a set of boundary nodes. The \textit{Solver} computes the data flow information
for the affected region and passes the results to the \textit{Merger}. \textit{Merger} merges the solution and produces the updated results.
Note that recreation of specifications for the given analysis is not required in Incremental analysis. Therefore, solver will use the old generated specifications.


\begin{figure}[t]
\centering
\psset{unit=1mm}
\begin{pspicture}(-20,-20)(115,90)

\begin{psframe}(-20,-20)(115,90)
\putnode{n1}{origin}{0}{80}{%
	  {\textbf{Old IR}}
     }
  
\putnode{n2}{n1}{40}{-5}{%
     \psframebox[linewidth=.3,framesep=1.7]{Preprocessor}}
     
\putnode{n3}{n1}{0}{-10}{%
	  {\textbf{New IR}}
     }
\putnode{n4}{n2}{50}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{Re-initializer}}
     
\putnode{n5}{n4}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{Solver}}

\putnode{n6}{n5}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{Merger}}
\putnode{n13}{n6}{-30}{0}{%
     {\textbf{Old Solution}}}
     
\putnode{n7}{n6}{0}{-20}{%
	  {\textbf{Updated Results}}
     }

\putnode{n8}{n5}{-40}{15}{%
     \psframebox[linewidth=.3,framesep=1.7]{Query specification}}
\putnode{n11}{n8}{18}{0}

\putnode{n9}{n5}{-40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{Utility functions}}

\putnode{n10}{n5}{-45}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{Data flow Analysis API}}
\putnode{n12}{n10}{22}{0}


\ncline{->}{n1}{n2}
\ncline{->}{n3}{n2}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncline{->}{n6}{n7}
\ncline{->}{n11}{n5}
\ncline{->}{n9}{n5}
\ncline{->}{n12}{n5}
\ncline{->}{n13}{n6}
\end{psframe}

\end{pspicture}
\caption{Architecture of Incremental PRISM}
    \label{fig:Architectur_incrementalPrism}
\end{figure}

\section{Modules of Incremental Solver}
The core PRISM solver was extended to support Incremental data flow analysis. Following modules are the extensions to the PRISM solver.
\begin{itemize}
 \item \texttt{IncrementalDriver}: This module takes two IRs as an input and calls \texttt{FLA$<$queryname$>$Client} to initiate the analysis.
 \item \texttt{FLA$<$queryname$>$Client}: This module discards the old IR after storing the old IR node information into \texttt{OldIRNode}
 and initiate incremental analysis of new IR.
 \item \texttt{CreateAffectedRegion}: This module detects the change in the control flow graph. It also detects affected region and a set of boundary nodes.
 The API functions which detects affected region and boundary nodes are as follows:
 \begin{itemize}
  \item \texttt{detectChangedNode(Application app)}: It compares old and new IRs and detect the changed nodes(or program points).
  \item \texttt{RDef$\_$affectednodes()}: It detects affected region for reaching definition analysis. Different analysis will have different method of computing affected region. 
  \item \texttt{findBoundaryNodesForwardAnalysis}: It detects boundary nodes for forward analysis. 
   \end{itemize}
 \item \texttt{OldIRWorklist}: This modules stores a list of old IR nodes.
\end{itemize}

% \subsection{Data Structures used by PRISM solver}
% In this section, we describe the data structures used in the implementation of incremental analysis. Following are the data structure used:
% \begin{itemize}
% 
%  \item oldIRnode: It stores old IR node information
%  \
% \end{itemize}

% \section{Steps to Run Incremental Driver}


\section{Incremental Reaching Definition Analysis}
Using Incremental Solver we have performed reaching definition analysis. It consists of two following parts:
% Specification for reaching definition analysis consist of following parts:
\begin{itemize}
\item Specification for reaching definition analysis
  \begin{itemize}
  \item \textbf{Node flow functions} Node flow functions consists of flow functions for 
 each statement.  It is specified in the Kulang specification. 
  \item \textbf{Meet function} This function merges information coming from two different nodes. It is specified in the Kulang specification.
  \item \textbf{Inter-procedural flow functions} These functions enable transferring information from a caller context to callee and vice versa.
 Since Kulang does not currently support specification for inter-procedural analysis, they are implemented in java.
\end{itemize}
\item Java code for creating affected region, :
\begin{itemize}
 \item \textbf{Creation of Affected Region} The function \texttt{RDef$\_$affectednodes()} creates affected region for reaching definition
 analysis. Ideally this should be generated by Kulang compiler. However, at the moment we have focused on the solver.
 Hence, it has been written manually. The effort to write a code is minimal as template function is provided and function required for given query 
 can be defined by making minimal changes to the template function.
%  The affected region creation algorithm, and hence the implementation depend on the kind of analysis.
 \end{itemize}
\end{itemize}


% \section{Issues in Implementing Incremental Analysis}
% \begin{itemize}
%  \item \textbf{Reading two IRs} The old solvers reads only a single IR. However, for incremental analysis we need both the old and new IR for comparison.
%  For this, we change the driver to take the two IRs and discard the old IR after storing the old IR node information.
%  \item Old solver output the results in a text file. For incremental update, we need to access the old solution of the program whose incremental analysis has to be done. 
%  However, re-creating all the abstractions from the text output is not possible owing to lack of source code that performed the serialization in the first place.
%  This thus involves some inherent loss of information.
% \end{itemize}

\section{Assumptions and Limitations }

The assumptions that we make are listed with the corresponding justifications as follows:
\begin{itemize}
\item \textbf{Pointer information will remain same.}
At present we have not implemented incremental analysis for general frameworks. So, it is not possible to incrementally update the pointer information.
% During runtime, a pointer may point to the heap and thus incrementally updating the pointer information would be complicated, which
% gives room to this simplifying assumption.
\item \textbf{There is no change in the context information.}
Otherwise, it is not possible to map old information to the new information.

\item \textbf{Declarations of variables haven't change.}
Change of declaration implies that there is a change in the lattice for that particular variable. For handling such changes, we need to 
run exhaustive analysis, incremental analysis won't suffice.
\item \textbf{There is no structural change in the graph.}
The reason for making this simplifying assumptions is that the output from the old solver is read from a text file. If the output was
serialized in form of PRISM objects, we could have handled structural changes as well.


% Violation of either of the above two assumption will necessitate another run of the exhaustive analysis.
\end{itemize}


The results from the old solver are stored in a text file, and not serialized into PRISM objects.
This renders it impossible to deserialize the results from the old solver and to serialize our results back.
Late discovery of this issue has prevented any corrective measures. Therefore, we take the following two assumptions. 
\begin{itemize}
\item A name can refer to a single variable in a program at any given program point.
\item The past information is stored flow sensitively.
\end{itemize}


The following are the main limitations of the Solver:
\begin{itemize}
%  \item Affected region which is analysis specific, the code for this has to be written manually.
 \item The result is stored in a non-standard format by the Solver.
 \end{itemize}

% However, under the above stated assumptions, the following only limitation that stems from reading from a
% text file is that the result is stored in a non standard format by the solver.


\section{Testing}
% In the absence of serialization of IR, 
Change in a practical code could means a change in a control flow graph and hence it was not possible to test the code for real world applications.
Therefore we had to artificially add the changes to check the performance of the Incremental Solver.
Some of the test cases that we used to check the Incremental Solver are as follows:
\begin{itemize}
 \item \textbf{Changed statement contains a definition of global variable} Consider the control flow graph in figure~\ref{fig:testCase1}. Let $a$ be a global variable
 and $n7$ be the changed node. The Affected region created by the solver is \textbf{AR} = $< n7, n9, n11, n15, n16 >$ and $n7$ is the boundary node.
 The nodes traversed by the solver are $<  n7, n9, n11, n15, n16 >$.
 \item \textbf{Changed statement contains a definition of local variable} Let $a$ be a local variable and $n7$ be the changed node in figure~\ref{fig:testCase1}.
 The affected region created by the solver is \textbf{AR} = $< n7, n9, n11, n12 >$ and boundary nodes are $n7$ and $n12$.
 The nodes traversed by the solver are $<  n7, n9, n11, n12 >$.
 \item Let the changed node be $n8$. Variable $z$ is passed as a parameter in function \textit{func1(z)} at $n10$. The affected region created by the solver is 
 \textbf{AR} = $< n8, n10, n21, n22, n23, n24, n25, n12, n3, n4 >$ and boundary nodes are $n8$ and $n3$. The node traversed by the solver are $< n8, n10, n21, n22, n23, n24, n25, n12, n3, n4 >$.
\end{itemize}

\begin{figure}[h]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,20)(150,250)
 \psframe(-20,0)(160,275)
\rput(60,270){\rnode{a}{main}}
\putnode{n1}{origin}{60}{265}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\rput(50,265){\rnode{a}{n1}}   

\putnode{n2}{n1}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{if( )}}
\rput(52,252){\rnode{a}{n2}}    

\putnode{n3}{n2}{25}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{while( )}}
\rput(74,239){\rnode{a}{n3}} 

\putnode{n4}{n3}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{$z=1$}}
\rput(76,226){\rnode{a}{n4}} 
     
\putnode{n5}{n4}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{if( )}}
\rput(76,213){\rnode{a}{n5}}

\putnode{n6}{n5}{-20}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{if( )}}
\rput(56,200){\rnode{a}{n6}}

\putnode{n8}{n6}{15}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{$z=$}}
\rput(71,187){\rnode{a}{n8}}
     
\putnode{n10}{n8}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{func1(z)}}
     \rput(67,174){\rnode{a}{n10}}

\putnode{n13}{n10}{-40}{0}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{\hspace{10mm}}}
     \rput(30,174){\rnode{a}{n13}}

\putnode{n14}{n13}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{\hspace{10mm}}}
     \rput(30,161){\rnode{a}{n14}}
     
\putnode{n7}{n5}{25}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{$a=$}}
\rput(103,200){\rnode{a}{n7}}

\putnode{n9}{n7}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{\hspace{10mm}}}
\rput(100,187){\rnode{a}{n9}}
     
\putnode{n11}{n9}{0}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{func( )}}
     \rput(99,174){\rnode{a}{n11}}

\putnode{n12}{n11}{-20}{-13}{%
     \psframebox[linewidth=.3,framesep=1.5, framearc=.4]{$a=$}}
     \rput(79,161){\rnode{a}{n12}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncline{->}{n5}{n7}
\ncline{->}{n7}{n9}
\ncline{->}{n9}{n11}
\ncline{->}{n11}{n12}
\ncline{->}{n6}{n8}
\ncline{->}{n8}{n10}
\ncline{->}{n10}{n12}
\ncline{->}{n6}{n13}
\ncline{->}{n13}{n14}
\ncline{->}{n2}{n13}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-30,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n12}{n3}
\rput(79,145){\rnode{a1}{(a)}}
		
		
\rput(20,125){\rnode{f1}{func()}}	
\putnode{n1}{origin}{20}{120}{%
     \psframebox[linewidth=.3,framesep=1.7]{ \hspace{10mm}}}
\rput(9,120){\rnode{a}{n15}}

\putnode{n0}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{$a=$}}
     \rput(10,105){\rnode{a}{n16}}

\putnode{n2}{n0}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
 
\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
 \rput(9,90){\rnode{a}{n17}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
 \rput(-11,75){\rnode{a}{n18}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
 \rput(9,60){\rnode{a}{n20}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
 \rput(28,75){\rnode{a}{n19}}

\rput(20,37){\rnode{b}{(b)}}
\ncline{->}{n1}{n0}
\ncline{->}{n0}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-30,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}
		
\rput(120,125){\rnode{f2}{func1()}}
\putnode{n1}{origin}{120}{120}{%
     \psframebox[linewidth=.3,framesep=1.7]{ \hspace{10mm}}}
 \rput(109,120){\rnode{a}{n21}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
 \rput(109,105){\rnode{a}{n22}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
 \rput(88,90){\rnode{a}{n23}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
 \rput(128,90){\rnode{a}{n24}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{$m=$}}
 \rput(110,75){\rnode{a}{n25}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(108,60){\rnode{a}{n26}}

\rput(120,45){\rnode{b}{(c)}}
\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
% \ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-30,
% 		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}


		
\end{pspicture}
\caption{Test case}
   \label{fig:testCase1}
\end{figure}
% 
% \section{Summary}
% The description of implemented driver is descriced 






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Issues in Incremental Analysis for General Frameworks}
The incremental analysis discussed in chapter 2 is restricted to bit-vector frameworks only.
Bit-vector frameworks cover a relatively simpler case where the data flow information of 
different entities is independent of each other. In situations where the data flow information
of entities is interdependent, a more general kind of flow functions are needed.
The corresponding general frameworks are called \emph{non-separable}.

In this chapter, we will discuss some of the issues in extending the existing incremental 
analysis to a general frameworks by means of constant propagation analysis.


\section{Issues in Incremental Analysis for Constant Propagation}
Consider a component lattice for Constant Propagation analysis in fig~\ref{fig:non_c_l}. Given a variable $x$ and a program point $u$, apart from associating integer constants
with $x$ at $u$, this analysis associates two additional values: \textit{undef} to indicate that no definition of $x$ has been seen along any path reaching $u$, and \textit{nonconst}
to indicate that $x$ can have different values at $u$ along different paths reaching $u$.

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,-10)(100,50)
%%\psframe(0,-10)(100,50)
\rput(50,40){\rnode{t1}{$\top$}}
\rput(50,35){\rnode{t2}{undef or ud}}
\rput(10,20){\rnode{c1}{$-\infty$}}
\rput(15,20){\rnode{c2}{$\cdots$}}
\rput(20,20){\rnode{c3}{$-3$}}
\rput(30,20){\rnode{c4}{$-2$}}
\rput(40,20){\rnode{c5}{$-1$}}
\rput(50,20){\rnode{c6}{$0$}}
\rput(60,20){\rnode{c7}{$1$}}
\rput(70,20){\rnode{c8}{$2$}}
\rput(80,20){\rnode{c9}{$3$}}
\rput(85,20){\rnode{c10}{$\cdots$}}
\rput(90,20){\rnode{c11}{$\infty$}}
\rput(50,5){\rnode{b1}{nonconst or nc}}
\rput(50,0){\rnode{b2}{$\bot$}}
\ncline{-}{t2}{c1}
%%\ncline{-}{t2}{c2}
\ncline{-}{t2}{c3}
\ncline{-}{t2}{c4}
\ncline{-}{t2}{c5}
\ncline{-}{t2}{c6}
\ncline{-}{t2}{c7}
\ncline{-}{t2}{c8}
\ncline{-}{t2}{c9}
%%\ncline{-}{t2}{c10}
\ncline{-}{t2}{c11}
\ncline{-}{b1}{c1}
%%\ncline{-}{b1}{c2}
\ncline{-}{b1}{c3}
\ncline{-}{b1}{c4}
\ncline{-}{b1}{c5}
\ncline{-}{b1}{c6}
\ncline{-}{b1}{c7}
\ncline{-}{b1}{c8}
\ncline{-}{b1}{c9}
%%\ncline{-}{b1}{c10}
\ncline{-}{b1}{c11}
\end{pspicture}
\caption[Component Lattice for Constant Propagation]{Component Lattice for Integer Constant Propagation}
   \label{fig:non_c_l}
\end{figure}


\subsection{Flow Functions}
Following are the possible flow functions in Constant Propagation analysis:
\begin{itemize}
\item Top : It is similar to the raise function in bit-vector frameworks. It always results in Top value.
\item Bottom : It is similar to the lower function in bit-vector frameworks. It always results in Bottom value.
 \item Constant : Function whose result is always constant. Consider a constant propagation analysis in fig~\ref{fig:flow_func_constant}(a),
 the flow function at node n2 will always produce a constant value 1 at the OUT of n2. There is one function per value.
  \item Side level : Consider a constant propagation analysis in fig~\ref{fig:flow_func_constant}(b), the value 
 of $a$ at node n3 depends on the value of $b$ and $c$. If $b$ and $c$ is constant, as in the figure, then $a$ will also become constant. If any of them
 is top/bottom then $a$ will become top/bottom.
 Flow functions for these type of statements whose value depends on the operands of the statement is known as side level function.
 \end{itemize}

\begin{figure}[h]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(0,50)
%%\psframe(0,0)(50,50)
\putnode{n1}{origin}{-20}{40}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n1}{-10}{0}{n1}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$b=1$}}
\putnode{a}{n2}{-10}{0}{n2}
\putnode{n3}{n2}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n3}{-10}{0}{n3}
\putnode{a1}{n3}{0}{-10}{(a)}


\putnode{n12}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$a=3$}}
\putnode{a}{n12}{-10}{0}{n1}
\putnode{n22}{n12}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$c=2$}}
\putnode{a}{n22}{-10}{0}{n2}
\putnode{n32}{n22}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$a=b+c$}}
\putnode{a}{n32}{-15}{0}{n3}
\putnode{a2}{n32}{0}{-10}{(b)}


\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n12}{n22}
\ncline{->}{n22}{n32}
\end{pspicture}
\caption[Additional possible flow functions]{Flow functions in Constant Propagation analysis}
   \label{fig:flow_func_constant}
\end{figure}

 
\subsection{Possible Changes in Flow Functions}
In addition to the changes given in section \ref{sec:bit-vector}, a change from intermediate
level to other levels is also possible.
\begin{itemize}
 \item a change to top,
 \item a change to bottom, and
 \item a side level change
\end{itemize}




\subsubsection{Change from intermediate level to top}
Consider a Constant propagation analysis in control flow graph shown in figure~\ref{fig:inter_otherlevels_upper}.
In this case, if expression $b=a$ is removed from the node then $b$ will become $\top$ at the OUT of node $n3$, a change from intermediate level to top($\bot$).
\begin{figure}[t]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,10)(150,85)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{27}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=1$}}
\rput(13,80){\rnode{a}{n1}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(15,65){\rnode{a}{n2}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\red$b=a$}}
\rput(-1,56){\rnode{a}{\blue$\langle b=1 \rangle$}}
\rput(17,50){\rnode{a}{n3}}
\rput(-1,44){\rnode{a}{\blue$\langle b=1 \rangle$}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(57,50){\rnode{a}{n4}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(38,35){\rnode{a}{n5}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(39,20){\rnode{a}{n6}}
\rput(27,10){\rnode{a1}{(a)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}

\putnode{n1}{origin}{101}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=1$}}
\rput(87,80){\rnode{a}{n1}}
\rput(87,85){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(87,74){\rnode{a}{\blue$\langle b=\top \rangle$}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(88,65){\rnode{a}{n2}}

\rput(101,58){\rnode{a}{\blue$\langle b=\top \rangle$}}
\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(74,56){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(92,50){\rnode{a}{n3}}

\rput(74,44){\rnode{a}{\blue$\langle b=\top  \rangle$}}
\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(109,50){\rnode{a}{n4}}
\rput(129,55){\rnode{a}{\blue$\langle b=\top \rangle$}}

\rput(129,45){\rnode{a}{\blue$\langle b=\top \rangle$}}
\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,30){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(89,40){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(89,35){\rnode{a}{n5}}
\rput(89,25){\rnode{a}{\blue$\langle b=\top \rangle$}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,20){\rnode{a}{n6}}
\rput(89,15){\rnode{a}{\blue$\langle b=\top\rangle$}}
\rput(101,10){\rnode{a1}{(b)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
                linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}



		
\end{pspicture}
\caption[Change from intermediate level to top]{Change from intermediate level to top}
   \label{fig:inter_otherlevels_upper}
\end{figure}

\subsubsection{Change from intermediate level to bottom}
Consider a control flow graph as shown in figure~\ref{fig:inter_otherlevels_lower}.
After a removal of expression $b=a$ at node $n4$, $b$ becomes bottom($\bot$) at 
the OUT of node $n4$ (as shown in figure~\ref{fig:inter_otherlevels_lower}(b)), a change from intermediate level to bottom($\bot$).

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,25)(150,90)
%%\psframe(0,15)(150,90)


\putnode{n1}{origin}{10}{80}{%
     \psframebox[linewidth=.3,framesep=0.5]{\begin{tabular}{c}$a=2$ \\$b=1$
                                             \end{tabular}}}
\rput(25,80){\rnode{a}{n1}}
\rput(-5,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(-5,74){\rnode{a2}{\blue$\langle b=1 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(60,80){\rnode{b}{n2}}
\rput(37,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(37,77){\rnode{b2}{\blue$\langle b=3 \rangle$}}

\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(40,65){\rnode{c}{n3}}
\rput(16,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(16,60){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=a$}}
\rput(40,50){\rnode{a}{n4}}
\rput(16,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(16,45){\rnode{c2}{\blue$\langle b=2 \rangle$}}



\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(40,35){\rnode{a}{n5}}
\rput(16,40){\rnode{c1}{\blue$\langle b=2 \rangle$}}
\rput(16,30){\rnode{c2}{\blue$\langle b=2 \rangle$}}

\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
% \ncline{->}{n5}{n6}


\putnode{n1}{origin}{90}{80}{%
     \psframebox[linewidth=.3,framesep=0.4]{\begin{tabular}{c}$a=2$ \\ $b=1$
                                             \end{tabular}}}
\rput(105,80){\rnode{a}{n1}}
\rput(76,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(76,74){\rnode{a2}{\blue$\langle b=1 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(140,80){\rnode{a}{n2}}
\rput(117,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(117,76){\rnode{b2}{\blue$\langle b=3 \rangle$}}


\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(120,65){\rnode{a}{n3}}
\rput(97,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(97,61){\rnode{c2}{\blue$\langle b=\bot \rangle$}}


\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(120,50){\rnode{a}{n4}}
\rput(97,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(97,46){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(120,35){\rnode{a}{n5}}
\rput(97,40){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(97,30){\rnode{c2}{\blue$\langle b=\bot \rangle$}}


\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
% \ncline{->}{n5}{n6}


		
\end{pspicture}
\caption[Change from intermediate level to bottom in general framework]{Change from intermediate level to bottom}
   \label{fig:inter_otherlevels_lower}
\end{figure}



\subsubsection{Side level change}
Consider a control flow graph as shown in figure~\ref{fig:inter_otherlevels}. Suppose, expression $b=a$ at node $n3$ has been removed as shown in 
figure~\ref{fig:inter_otherlevels}(b). Due to this change $b$ becomes $2$ at the OUT of node $n3$, a side level change in the lattice.

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,10)(150,90)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{27}{80}{%
     \psframebox[linewidth=.3,framesep=0.5]{\begin{tabular}{c}$a=1$ \\ $b=2$
                                             \end{tabular}}}
\rput(13,80){\rnode{a}{n1}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(15,65){\rnode{a}{n2}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\red$b=a$}}
\rput(-1,56){\rnode{a}{\blue$\langle b=\bot \rangle$}}
\rput(17,50){\rnode{a}{n3}}
\rput(-1,44){\rnode{a}{\blue$\langle b=1 \rangle$}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(57,50){\rnode{a}{n4}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(38,35){\rnode{a}{n5}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(39,20){\rnode{a}{n6}}
\rput(27,10){\rnode{a1}{(a)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}

\putnode{n1}{origin}{101}{80}{%
     \psframebox[linewidth=.3,framesep=0.5]{\begin{tabular}{c}$a=1$ \\ $b=2$
                                             \end{tabular}}}
\rput(87,80){\rnode{a}{n1}}
\rput(87,85){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(87,74){\rnode{a}{\blue$\langle b=2 \rangle$}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(88,65){\rnode{a}{n2}}

\rput(101,58){\rnode{a}{\blue$\langle b=2\rangle$}}
\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(74,56){\rnode{a}{\blue$\langle b=2\rangle$}}
\rput(92,50){\rnode{a}{n3}}

\rput(74,44){\rnode{a}{\blue$\langle b=2 \rangle$}}
\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(109,50){\rnode{a}{n4}}
\rput(129,55){\rnode{a}{\blue$\langle b=2 \rangle$}}

\rput(129,45){\rnode{a}{\blue$\langle b=2 \rangle$}}
\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,30){\rnode{a}{\blue$\langle b=2 \rangle$}}
\rput(89,40){\rnode{a}{\blue$\langle b=2 \rangle$}}
\rput(89,35){\rnode{a}{n5}}
\rput(89,25){\rnode{a}{\blue$\langle b=2 \rangle$}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,20){\rnode{a}{n6}}
\rput(89,15){\rnode{a}{\blue$\langle b=2 \rangle$}}
\rput(101,10){\rnode{a1}{(b)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
                linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}



		
\end{pspicture}
\caption[Side level change in lattice]{Side level change}
   \label{fig:inter_otherlevels}
\end{figure}

\subsection{Need for Affected Region for Every Change }

Unlike bit-vector frameworks when there is a change to bottom, we cannot directly propagate
the change to its neighboring nodes since it may depend on the OUT information of the node.
We illustrate this via an example in figure \ref{fig:incr_non-bit1}. If expression $b=2$ is removed,
then according to existing incremental analysis, this is a change to bottom and we can directly propagate
the change to its neighboring nodes. However, this is incorrect. 
The information at the IN of node 4 is bottom because of the expression $b=2$ in node 4.
If we will propagate $\bot$ to neighboring nodes, it will give incorrect results.
Unlike bit-vector frameworks, we may need to create an affected region even if there is a change to bottom.
Thus, the solution is to create an affected region for all kind of changes.
\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,20)(100,90)
% \psframe(0,20)(100,90)
\putnode{n1}{origin}{30}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(20,80){\rnode{a}{n1}}
\rput(29,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(29,74){\rnode{a2}{\blue$\langle b=3 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(59,80){\rnode{b}{n2}}
\rput(70,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(70,74){\rnode{b2}{\blue$\langle b=3 \rangle$}}

\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(39,65){\rnode{c}{n3}}
\rput(37,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(37,60){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=2$}}
\rput(39,50){\rnode{a}{n4}}
\rput(37,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(37,45){\rnode{c2}{\blue$\langle b=2 \rangle$}}

\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(39,35){\rnode{a}{n5}}
\rput(37,40){\rnode{c1}{\blue$\langle b=2 \rangle$}}
\rput(37,30){\rnode{c2}{\blue$\langle b=2 \rangle$}}

\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-15,
                linearc=0.5,offsetA=1, offsetB=1]{->}{n5}{n3}

\end{pspicture}
\caption{Constant propagation analysis}
   \label{fig:incr_non-bit1}
\end{figure}



\section{Reducing the size of Affected Region}
We outline an optimization idea to reduce the size of the affected region which can 
eliminate certain boundary nodes from being included in the affected region.
This optimization is based on the observation that some boundary nodes can be characterized
by the concept of \emph{dominance frontier}. We define the concept of \textit{Dominance Frontier} before elaborating on the optimization idea.

\subsection*{Dominance Frontier}

Let $n$ and $m$ be nodes in the CFG. The node $n$ is said to \textit{dominate} $m$ ($n\geq m$), if every path from \textbf{Start} to $m$ passes through $n$.
If $n \neq m$, then $n$ \textit{strictly dominates} $m$ and is denotes as $n > m$.  

The \textit{dominance frontier}~\cite{book} of a node $n$, denoted by \textbf{df(n)} is given as:
\begin{equation}
\begin{split}
\mbox{\textit{df(n)}} &= \{ m \mid \exists p \in \textit{pred(m)}, ( n \geq p \mbox{ and } n \ngtr m )\} \\	  
\end{split} 
\end{equation}

Consider a graph in figure \ref{fig:dominance_frontier}. Node $n1$ contains a definition of $x$. Node $n4$ is \textit{dominated} by node $n1$. Consider a node $n5$, which is a 
immediate successor of $n4$, is node dominated by $n1$. Node such as $n5$, is said to be in the \textit{dominance frontier} of $n1$. 

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,40)(100,90)
% \psframe(0,20)(100,90)
\putnode{n0}{origin}{40}{90}{}
\putnode{n1}{n0}{0}{-10}{%
     \psframebox[linewidth=.3,framesep=1.7]{$x=$}}
\rput(30,80){\rnode{a}{n1}}

\putnode{n2}{n1}{-15}{-10}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(15,70){\rnode{a}{n2}}

\putnode{n3}{n1}{15}{-10}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(45,70){\rnode{a}{n3}}

\putnode{n4}{n1}{0}{-20}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(30,60){\rnode{a}{n4}}

\putnode{n5}{n4}{-10}{-10}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(20,50){\rnode{a}{n5}}

\putnode{n6}{n2}{-5}{-10}{}


\ncline{->}{n0}{n1}
\ncline{->}{n1}{n2}
\ncline{->}{n1}{n3}
\ncline{->}{n2}{n4}
\ncline{->}{n3}{n4}
\ncline[linecolor = red]{->}{n6}{n5}
\ncline{->}{n4}{n5}

\end{pspicture}
\caption{Figure shows a dominance frontier of $n1$}
   \label{fig:dominance_frontier}
\end{figure}

We first illustrate via an example that dominance frontier nodes are a subset of the boundary nodes. 
We then establish that all the possible candidates of removal form a dominance frontier.
Given these two facts, it follows that the nodes that can be deleted can be identified during the AR 
construction itself, without further delays.

\paragraph{All Dominance Frontier nodes are Boundary nodes (but not vice versa)}
Consider a node $n$, in an affected region (AR) and $c$ be the changed node. If $n$ is a dominance frontier of $c$,
then $n$ must be a boundary node. This follows from the fact that there is some path that reaches $m$ without passing through the changed node $c$. But if some node $m$ is a boundary node of AR(C), then $m$ need not be a dominance frontier.
We explain this via an example in figure~\ref{fig:eg_dominance_frontier}. If $i$ is a changed node, then $AR(i) = <i, j, l, m, n>$
Here $m$ is a boundary node but it is dominated by block $i$ and hence not its dominance frontier.

\begin{figure}[!htb]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(100,90)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{50}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=$}}
\rput(40,80){\rnode{a}{i}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{$if(e)$}}
\rput(40,65){\rnode{a}{j}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{$a=2$}}
\rput(20,50){\rnode{a}{k}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=2$}}
\rput(60,50){\rnode{a}{l}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(40,35){\rnode{a}{m}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(40,20){\rnode{a}{n}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
% \ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-30,
% 		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}
		
\end{pspicture}
\caption{Control flow graph for constant propagation analysis}
   \label{fig:eg_dominance_frontier}
\end{figure}


\paragraph{Possible Removal Candidates Form a Dominance Frontier}
Let us consider the example in figure~\ref{fig:incr_non-bit2}.
Let the changed node be $n5$. The affected region (AR) will contain the nodes $n5, n6, n7, n3$ and $n4$ with the node 
 $n3$ as the boundary node. The information coming from nodes $n1$ and $n2$ will keep the value at the IN of $n3 = \bot$.
The information coming from $OUT$ of $n7$ will not affect the $IN$ information of $n3$, and thus the information of the successors of $n3$.
This implies that we can exclude the node $n3$, and thus its successor $n4$ from the affected region, reducing the size of the latter.
We further note that the node $n3$ must be a dominance frontier of the change node ($n4$).

\begin{figure}[t]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(100,90)
% \psframe(0,20)(100,90)
\putnode{n1}{origin}{30}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=2$}}
\rput(20,80){\rnode{a}{n1}}
\rput(29,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(29,74){\rnode{a2}{\blue$\langle b=2 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=1$}}
\rput(59,80){\rnode{b}{n2}}
\rput(70,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(70,74){\rnode{b2}{\blue$\langle b=1 \rangle$}}

\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(39,65){\rnode{c}{n3}}
\rput(37,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(37,60){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(39,50){\rnode{a}{n4}}
\rput(37,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(37,45){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(39,35){\rnode{a}{n5}}
\rput(37,40){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(37,30){\rnode{c2}{\blue$\langle b=3 \rangle$}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(39,20){\rnode{c}{n6}}
\rput(37,23){\rnode{c1}{\blue$\langle b=3 \rangle$}}
\rput(37,16){\rnode{c2}{\blue$\langle b=3 \rangle$}}
      
\putnode{n7}{n6}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(39,5){\rnode{c}{n7}}
\rput(37,8){\rnode{c1}{\blue$\langle b=3 \rangle$}}
\rput(37,1){\rnode{c2}{\blue$\langle b=3 \rangle$}}

\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncline{->}{n6}{n7}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-15,
                linearc=0.5,offsetA=1, offsetB=1]{->}{n7}{n3}

\end{pspicture}
\caption{Constant propagation analysis}
   \label{fig:incr_non-bit2}
\end{figure}




\paragraph{Reducing the size of the affected region}
It follows from the above discussion that it is possible to identify such boundary nodes (dominance frontier of changed node) during AR construction.
All such nodes have an outside influence. If the outside influence keeps the value to $\bot$ (or does not allow it to change), 
then there is no need to include this node in AR. This can help in reducing the size of AR.
In general frameworks, we need to create AR for almost all the cases. However, we can still reduce the size of the affected region. This optimization is applicable
for bit-vector vector frameworks also. 

 

\section{Summary}
In general frameworks, we need to create affected region for almost every kind of change. However it is possible to reduce the size of affected region by excluding boundary
nodes where outside influence keeps the values at IN to $\bot$. This optimization can work only on a change in a program. Handling for multiple changes need to be studied.



\begin{comment}
\section{Incremental Analysis in Non Bit-vector Framework}
\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,-10)(100,50)
%%\psframe(0,-10)(100,50)
\rput(50,40){\rnode{t1}{$\top$}}
\rput(50,35){\rnode{t2}{undef or ud}}
\rput(10,20){\rnode{c1}{$-\infty$}}
\rput(15,20){\rnode{c2}{$\cdots$}}
\rput(20,20){\rnode{c3}{$-3$}}
\rput(30,20){\rnode{c4}{$-2$}}
\rput(40,20){\rnode{c5}{$-1$}}
\rput(50,20){\rnode{c6}{$0$}}
\rput(60,20){\rnode{c7}{$1$}}
\rput(70,20){\rnode{c8}{$2$}}
\rput(80,20){\rnode{c9}{$3$}}
\rput(85,20){\rnode{c10}{$\cdots$}}
\rput(90,20){\rnode{c11}{$\infty$}}
\rput(50,5){\rnode{b1}{nonconst or nc}}
\rput(50,0){\rnode{b2}{$\bot$}}
\ncline{-}{t2}{c1}
%%\ncline{-}{t2}{c2}
\ncline{-}{t2}{c3}
\ncline{-}{t2}{c4}
\ncline{-}{t2}{c5}
\ncline{-}{t2}{c6}
\ncline{-}{t2}{c7}
\ncline{-}{t2}{c8}
\ncline{-}{t2}{c9}
%%\ncline{-}{t2}{c10}
\ncline{-}{t2}{c11}
\ncline{-}{b1}{c1}
%%\ncline{-}{b1}{c2}
\ncline{-}{b1}{c3}
\ncline{-}{b1}{c4}
\ncline{-}{b1}{c5}
\ncline{-}{b1}{c6}
\ncline{-}{b1}{c7}
\ncline{-}{b1}{c8}
\ncline{-}{b1}{c9}
%%\ncline{-}{b1}{c10}
\ncline{-}{b1}{c11}
\end{pspicture}
\caption[Component Lattice for Constant Propagation]{Component Lattice for Integer Constant Propagation}
   \label{fig:non_c_l}
\end{figure}

Consider a component lattice for Constant Propagation analysis in fig~\ref{fig:non_c_l}. Following are the possible flow functions in Constant Propagation analysis:
\begin{itemize}
\item Top : It is similar to the raise function in bit-vector framework. It always results in Top value.
\item Bottom : It is similar to the lower function in bit-vector framework. It always results in Bottom value.
 \item Constant : Function whose result is always constant. Consider a constant propagation analysis in fig~\ref{fig:flow_func_constant}(a),
 the flow function at node n2 will always produce a constant value 1 at the OUT of n2. There is one function per value.
  \item Side level : Consider a constant propagation analysis in fig~\ref{fig:flow_func_constant}(b), the value 
 of $a$ at node n3 depends on the value of $b$ and $c$. If $b$ and $c$ is constant, as in the figure, then $a$ will also become constant. If any of them
 is top/bottom then $a$ will become top/bottom.
 Flow functions for these type of statements whose value depends on the operands of the statement is known as side level function.
 \end{itemize}

\begin{figure}[h]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(0,50)
%%\psframe(0,0)(50,50)
\putnode{n1}{origin}{-20}{40}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n1}{-10}{0}{n1}
\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$b=1$}}
\putnode{a}{n2}{-10}{0}{n2}
\putnode{n3}{n2}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{\hspace{10mm}}}
\putnode{a}{n3}{-10}{0}{n3}
\putnode{a1}{n3}{0}{-10}{(a)}


\putnode{n12}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$a=3$}}
\putnode{a}{n12}{-10}{0}{n1}
\putnode{n22}{n12}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$c=2$}}
\putnode{a}{n22}{-10}{0}{n2}
\putnode{n32}{n22}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5, framearc=.4]{$a=b+c$}}
\putnode{a}{n32}{-15}{0}{n3}
\putnode{a2}{n32}{0}{-10}{(b)}


\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n12}{n22}
\ncline{->}{n22}{n32}
\end{pspicture}
\caption[Additional possible flow functions]{Flow functions in Constant Propagation analysis}
   \label{fig:flow_func_constant}
\end{figure}

 
\subsection{Changes in Constant Propagation analysis}
In addition to the changes given in section \ref{sec:bit-vector}, a change from intermediate
level to other levels is also possible.
\begin{itemize}
 \item a change to top,
 \item a change to bottom, and
 \item a side level change
\end{itemize}




\subsubsection{Change from intermediate level to top}
Consider a Constant propagation analysis in control flow graph shown in figure~\ref{fig:inter_otherlevels_upper}.
In this case, if expression $b=a$ is removed from the node then $b$ will become $\top$ at the OUT of node $n3$, a change from intermediate level to top($\bot$).
\begin{figure}[t]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,10)(150,90)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{27}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=1$}}
\rput(13,80){\rnode{a}{n1}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(15,65){\rnode{a}{n2}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\red$b=a$}}
\rput(-1,56){\rnode{a}{\blue$\langle b=1 \rangle$}}
\rput(17,50){\rnode{a}{n3}}
\rput(-1,44){\rnode{a}{\blue$\langle b=1 \rangle$}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(57,50){\rnode{a}{n4}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(38,35){\rnode{a}{n5}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(39,20){\rnode{a}{n6}}
\rput(27,10){\rnode{a1}{(a)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}

\putnode{n1}{origin}{101}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{ $a=1$}}
\rput(87,80){\rnode{a}{n1}}
\rput(87,85){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(87,74){\rnode{a}{\blue$\langle b=\top \rangle$}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(88,65){\rnode{a}{n2}}

\rput(101,58){\rnode{a}{\blue$\langle b=\top \rangle$}}
\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(74,56){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(92,50){\rnode{a}{n3}}

\rput(74,44){\rnode{a}{\blue$\langle b=\top  \rangle$}}
\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(109,50){\rnode{a}{n4}}
\rput(129,55){\rnode{a}{\blue$\langle b=\top \rangle$}}

\rput(129,45){\rnode{a}{\blue$\langle b=\top \rangle$}}
\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,30){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(89,40){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(89,35){\rnode{a}{n5}}
\rput(89,25){\rnode{a}{\blue$\langle b=\top \rangle$}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,20){\rnode{a}{n6}}
\rput(89,15){\rnode{a}{\blue$\langle b=\top\rangle$}}
\rput(101,10){\rnode{a1}{(b)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
                linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}



		
\end{pspicture}
\caption[Change from intermediate level to top]{Change from intermediate level to top}
   \label{fig:inter_otherlevels_upper}
\end{figure}

\subsubsection{Change from intermediate level to bottom}
Consider a control flow graph as shown in figure~\ref{fig:inter_otherlevels_lower}.
After a removal of expression $b=a$ at node $n4$, $b$ becomes bottom($\bot$) at 
the OUT of node $n4$ (as shown in figure~\ref{fig:inter_otherlevels_lower}(b)), a change from intermediate level to bottom($\bot$).

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,25)(150,90)
%%\psframe(0,15)(150,90)


\putnode{n1}{origin}{10}{80}{%
     \psframebox[linewidth=.3,framesep=0.5]{\begin{tabular}{c}$a=2$ \\$b=1$
                                             \end{tabular}}}
\rput(25,80){\rnode{a}{n1}}
\rput(-5,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(-5,74){\rnode{a2}{\blue$\langle b=1 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(60,80){\rnode{b}{n2}}
\rput(37,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(37,77){\rnode{b2}{\blue$\langle b=3 \rangle$}}

\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(40,65){\rnode{c}{n3}}
\rput(16,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(16,60){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=a$}}
\rput(40,50){\rnode{a}{n4}}
\rput(16,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(16,45){\rnode{c2}{\blue$\langle b=2 \rangle$}}



\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(40,35){\rnode{a}{n5}}
\rput(16,40){\rnode{c1}{\blue$\langle b=2 \rangle$}}
\rput(16,30){\rnode{c2}{\blue$\langle b=2 \rangle$}}

\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
% \ncline{->}{n5}{n6}


\putnode{n1}{origin}{90}{80}{%
     \psframebox[linewidth=.3,framesep=0.4]{\begin{tabular}{c}$a=2$ \\ $b=1$
                                             \end{tabular}}}
\rput(105,80){\rnode{a}{n1}}
\rput(76,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(76,74){\rnode{a2}{\blue$\langle b=1 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(140,80){\rnode{a}{n2}}
\rput(117,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(117,76){\rnode{b2}{\blue$\langle b=3 \rangle$}}


\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(120,65){\rnode{a}{n3}}
\rput(97,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(97,61){\rnode{c2}{\blue$\langle b=\bot \rangle$}}


\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(120,50){\rnode{a}{n4}}
\rput(97,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(97,46){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(120,35){\rnode{a}{n5}}
\rput(97,40){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(97,30){\rnode{c2}{\blue$\langle b=\bot \rangle$}}


\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
% \ncline{->}{n5}{n6}


		
\end{pspicture}
\caption[Change from intermediate level to bottom in Non-bit vector frameworks]{Change from intermediate level to bottom}
   \label{fig:inter_otherlevels_lower}
\end{figure}



\subsubsection{Side level change}
Consider a control flow graph as shown in figure~\ref{fig:inter_otherlevels}. Suppose, expression $b=a$ at node $n3$ has been removed as shown in 
figure~\ref{fig:inter_otherlevels}(b). Due to this change $b$ becomes $2$ at the OUT of node $n3$, a side level change in the lattice.

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,10)(150,90)
%%\psframe(0,0)(100,90)
\putnode{n1}{origin}{27}{80}{%
     \psframebox[linewidth=.3,framesep=0.5]{\begin{tabular}{c}$a=1$ \\ $b=2$
                                             \end{tabular}}}
\rput(13,80){\rnode{a}{n1}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(15,65){\rnode{a}{n2}}

\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\red$b=a$}}
\rput(-1,56){\rnode{a}{\blue$\langle b=\bot \rangle$}}
\rput(17,50){\rnode{a}{n3}}
\rput(-1,44){\rnode{a}{\blue$\langle b=1 \rangle$}}

\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(57,50){\rnode{a}{n4}}

\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(38,35){\rnode{a}{n5}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(39,20){\rnode{a}{n6}}
\rput(27,10){\rnode{a1}{(a)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
		linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}

\putnode{n1}{origin}{101}{80}{%
     \psframebox[linewidth=.3,framesep=0.5]{\begin{tabular}{c}$a=1$ \\ $b=2$
                                             \end{tabular}}}
\rput(87,80){\rnode{a}{n1}}
\rput(87,85){\rnode{a}{\blue$\langle b=\top \rangle$}}
\rput(87,74){\rnode{a}{\blue$\langle b=2 \rangle$}}

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{if($a\geq2$)}}
\rput(88,65){\rnode{a}{n2}}

\rput(101,58){\rnode{a}{\blue$\langle b=2\rangle$}}
\putnode{n3}{n2}{-20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(74,56){\rnode{a}{\blue$\langle b=2\rangle$}}
\rput(92,50){\rnode{a}{n3}}

\rput(74,44){\rnode{a}{\blue$\langle b=2 \rangle$}}
\putnode{n4}{n2}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(109,50){\rnode{a}{n4}}
\rput(129,55){\rnode{a}{\blue$\langle b=2 \rangle$}}

\rput(129,45){\rnode{a}{\blue$\langle b=2 \rangle$}}
\putnode{n5}{n2}{0}{-30}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,30){\rnode{a}{\blue$\langle b=2 \rangle$}}
\rput(89,40){\rnode{a}{\blue$\langle b=2 \rangle$}}
\rput(89,35){\rnode{a}{n5}}
\rput(89,25){\rnode{a}{\blue$\langle b=2 \rangle$}}

\putnode{n6}{n5}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=2.5]{\hspace{10mm}}}
\rput(89,20){\rnode{a}{n6}}
\rput(89,15){\rnode{a}{\blue$\langle b=2 \rangle$}}
\rput(101,10){\rnode{a1}{(b)}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n5}
\ncline{->}{n2}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n5}{n6}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-33,
                linearc=0.5,offsetA=2, offsetB=2]{->}{n5}{n2}



		
\end{pspicture}
\caption[Side level change in lattice]{Side level change}
   \label{fig:inter_otherlevels}
\end{figure}


\section{Issues in Incremental Analysis for Constant Propagation}
Consider the example in figure~\ref{fig:incr_non-bit1}. Unlike bit-vector frameworks, the information at IN of the node $n4$ is dependent on the information
at its OUT. Now suppose that this expression is removed due to some change in the program. To incorporate this change, if we propagate the IN
information to its neighbour then this will give incorrect result. In such cases, when the IN information of a node is dependent on 
the information at its OUT, affected region needs to be created. We next elaborate on detection of such cases.
\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,20)(100,90)
% \psframe(0,20)(100,90)
\putnode{n1}{origin}{40}{80}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(30,80){\rnode{a}{n1}}
\rput(39,86){\rnode{a1}{\blue$\langle b=\top \rangle$}}
\rput(39,74){\rnode{a2}{\blue$\langle b=3 \rangle$}}

\putnode{n2}{n1}{40}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=3$}}
\rput(69,80){\rnode{b}{n2}}
\rput(80,86){\rnode{b1}{\blue$\langle b=\top \rangle$}}
\rput(80,74){\rnode{b2}{\blue$\langle b=3 \rangle$}}

\putnode{n3}{n1}{20}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(49,65){\rnode{c}{n3}}
\rput(47,69){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(47,60){\rnode{c2}{\blue$\langle b=\bot \rangle$}}

\putnode{n4}{n1}{20}{-30}{%
     \psframebox[linewidth=.3,framesep=1.7]{$b=2$}}
\rput(49,50){\rnode{a}{n4}}
\rput(47,55){\rnode{c1}{\blue$\langle b=\bot \rangle$}}
\rput(47,45){\rnode{c2}{\blue$\langle b=2 \rangle$}}

\putnode{n5}{n1}{20}{-45}{%
     \psframebox[linewidth=.3,framesep=1.7]{\hspace{10mm}}}
\rput(49,35){\rnode{a}{n5}}
\rput(47,40){\rnode{c1}{\blue$\langle b=2 \rangle$}}
\rput(47,30){\rnode{c2}{\blue$\langle b=2 \rangle$}}

\ncline{->}{n1}{n3}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncloop[armA=3,armB=3,angleA=-90,angleB=90,loopsize=-15,
                linearc=0.5,offsetA=1, offsetB=1]{->}{n5}{n3}

\end{pspicture}
\caption{Constant propagation analysis}
   \label{fig:incr_non-bit1}
\end{figure}

%Now the problem is to detect whether the IN information is dependent on the information at its OUT of the node or not. 
\subsection{Detecting Dependencies of IN Information on OUT information for a node}
We first list the necessary definitions before presenting the dependency detection algorithm.

\begin{itemize}
 \item \textbf{Changed Node}: A node which has been changed during program development. Node $n4$ in figure~\ref{fig:incr_non-bit1} is a \textit{Changed Node}
\item \textbf{Meet Node}:
A node $N$ should satisfy the following the criteria in order to be called a meet node.
\begin{itemize}
\item $N\in$\textit{dominant frontier} \footnote{TODO: define the dominant frontier or add reference}
\item There exits a path, $p$, from a \textit{Changed Node} to $N$ and vice versa.
\item The path $p$ should not have any re-definition of the assigned variable in the changed expression. 
\end{itemize}

As an example, consider figure~\ref{fig:incr_non-bit1}. The node $n4$ is a changed node.
The expression \emph{\textbf{b=2}} in the Changed Node $n4$, is called the changed expression.
As per the criteria defined above, for the node $n3$ to be a meet node, the variable $b$ should not be 
re-assigned in the path from $n4$ to $N$ and vice versa.
\end{itemize}

Given a changed node $N$, the detection process proceeds as follows
\begin{enumerate}
 \item If the IN information of $N$ is not TOP, proceed to step 2, otherwise proceed to step 5.
 \item If a Meet Node, $M$, exists, proceed to step 3, otherwise proceed to step 5.
 \item Let $INInfo \gets$ Information at IN of $M$ excluding Infomation coming from $N$. If $INInfo \ne \bot$, proceed to step 4.
 otherwise proceed to step 5.
 \item Create Affected Region.
 \item Affected Region Need Not be Created.
 \end{enumerate}
  
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusions and Future Work}
%  
% This report describes the method of doing incremental analysis in bit-vector frameworks. This method performs incremental analysis for a single change in a program
% but in general multiple changes are also possible, so we need a method which can also perform incremental analsis for multiple changes.
% It also describes some issues in doing incremental analysis in Constant propagation. In Consant propagation we need to create affected region for almost all the cases.
% We may restrict the size of the affected region even if we cannot avoid it. We need some method so that we can restrict the size of the affected region which will be one 
% of our future work.
% 
% Current PRISM frameworks supports context sensitive bi-directional analysis. Incremental analysis is not yet implemented in current frameworks. As a part
% of first stage of the project, queries for both reaching definition analysis with and without liveness have been implemented.
% 
% The current specification does not allow the user to specify data flow variables and equations as seen in literature. It places contraints on the type of analysis 
% defined. It allows those analysis which has single data flow variable. Therefore, the anlysis writer needs to convert multi-variable equation to single-variable 
% equation which is an extra work done by the writer. The specifications can be extended to allow analysis containig multiple variables.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Incremental analysis is a method of avoiding redundant analysis in the case when only a part of the program has changed.
In this report, we discussed the theory and implementation of incremental analysis for bit-vector frameworks, and 
proposed methods of extending it to general frameworks. The experiments on our test set have yielded motivating results.
We also sketch a number of possible improvements in the implementation that may add to the performance and scalability of
the incremental solver.


The following three limitations prevent us from testing our solver on real life, industry scale code bases:
\begin{itemize}

 \item \textbf{Non inclusion of global and local declarations} PRISM solver is not including local and global declarations as a statement which may result in
 a loss of information.
 \item \textbf{Persistence of Results} The results of PRISM solver are currently written to a text file, whereas they should 
 ideally be packed in a \emph{result} object provided by the PRISM Solver and persisted.
%  \item \textbf{Creation of Affected Region} From the fact that creation of affected region is a analysis specific, currently the code for this has to be written manually.
%  Future work is to change the Kulang compiler to generate the affected region from the flow function.
%  
\end{itemize}

Resolving these issues will help us in exposing our solver to some new challenges that might lead to new insights and avenues for improvements.
Some other future work is to quantifying the size of the affected region for bug fixes and exploring some method to detect when it is more beneficial
to do incremental analysis than exhaustive analysis.


We have proposed a new idea for the optimization of affected region (AR). The idea is framework agnostic
(can be fitted to both bit vector and general frameworks), and may lead to significant time savings when
incorporated in the solver.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\bibname}{References}
\begin{small}
\bibliography{report1}
\bibliographystyle{plain}
\end{small}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\chapter{Bi-directional Solver}\label{ap:BidirectionalSolver}
In this section, we describe the implementation of core Bi-directional \emph{PRISM} solver. The core bi-directional solver 
integrates with the generated bi-directional solver from kulang compiler and solves the given data flow problem in a context
sensitive manner. The solver is the main driver of the data flow analysis. Its role in the data flow analysis is shown in 
figure \ref{fig:solverstructure}. In this chapter we describe the modules of bidirectional solver and data structures used 
by core solver.
% Finally we describe the implementation of Liveness based Flow and Context sensitive pointer analysis which 
% was implemented for the bidirectional solver.

\begin{figure}[H]
\centering
\psset{unit=1mm}
\begin{pspicture}(-20,15)(115,90)

\begin{psframe}(-20,15)(115,90)
\putnode{n1}{origin}{75}{80}{%
	  {\textbf{Program}}
     }

\putnode{n2}{n1}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{IR Generator}}

\putnode{n3}{n2}{0}{-10}{%
     {\textbf{Generated IR}}}

\putnode{n4}{n3}{0}{-15}{%
     \psframebox[linewidth=.3,framesep=1.7]{Solver}}

\putnode{n5}{n4}{30}{0}{{\textbf{Results}}}

\putnode{n6}{n4}{-55}{0}{%
     \psframebox[linewidth=.3,framesep=1.7]{Kulang Compiler}}

% \putnode{n8}{n6}{0}{15}{%
%      {Copied}}
% \rput(55,33){\rnode{a}{Generated}}
\putnode{n7}{n6}{-30}{0}{%
      {\textbf{.klg files}}}

\putnode{n8}{n6}{5}{15}{%
     \psframebox[linewidth=.3,framesep=1.7]{Other Utility functions}}
\putnode{n9}{n7}{64}{-6}{%
     {Generated Java files}}

\ncline{->}{n1}{n2}
\ncline{->}{n2}{n3}
\ncline{->}{n3}{n4}
\ncline{->}{n4}{n5}
\ncline{->}{n6}{n4}
\ncline{->}{n7}{n6}
% \nccurve[angleA=0, angleB=100, ncurv=0.5]{->}{n7}{n6}
\ncline{->}{n8}{n4}
\end{psframe}

\end{pspicture}
\caption{Role of PRISM solver}
\label{fig:solverstructure}
\end{figure}

\subsection*{Modules of Bidirectional solver}
The  core \emph{PRISM} solver was extended to support bi-directional data flow problems. 
The following modules are the extensions to the \emph{PRISM} solver:

\begin{enumerate}
\item \emph{DFStore}: This module stores context sensitive data flow information and provides an API to access it. The class diagram for this module 
is shown in figure \ref{fig:dfstore}.

It stores data flow values at IN/OUT of every node. The information at IN/OUT consist of \emph{(contextId, dataflow information)} pairs. 
A Hashmap is used to store this information. The key of the Hashmap consists of program statement or \emph{ICFGNode} and the value consists
of another HashMap containing \emph{(contextId, data flow value)} pairs.

% 
% The key value mapping for the data structure is,
% \newline
% \emph{program point $\rightarrow $ pointer to value hashmap}
% \newline
% \newline
% In the retrieved hashmap from the previous mapping values are mapped as, 
% \newline
% \emph{(context id) $\rightarrow $ data flow value}
% \newline
% \newline



\begin{figure}
\includegraphics[scale=0.8]{class_diagrams/updatedClassDiagrams/DFStore_C.eps}
\caption{Class Diagram for DFStore}
\label{fig:dfstore}
\end{figure}


\item \emph{ValueContexts}: This module holds information about contexts formed during the analysis.
The class diagram for this module is shown in figure \ref{fig:valuecontexts}.

ValueContexts stores information of value contexts and maps each value context to a unique context id. 
It is implemented using a Vector which provides fast random access to query information about a value context. Each cell of the vector corresponds to
a context id and stores information about context of the corresponding context id. 

An API is defined to store and retrieve values from the data structure. It is implemented in \emph{ValueContexts.java} in the \emph{DFSolver} package. 
The data structure is shown in figure \ref{fig:valuecontexts}.

\begin{figure}[!ht]
\centering
\psset{unit=1mm}
\begin{pspicture}(0,0)(150,80)
\begin{psframe}(0,0)(129,80)
\putnode{n0}{origin}{20}{60}{\psframebox{~~} }
\putnode{n1}{n0}{5}{0}{\psframebox{~~} }
\putnode{n2}{n1}{5}{0}{\psframebox{~~} }
\putnode{n3}{n2}{5}{0}{\psframebox{~~} }
\putnode{n4}{n3}{5}{0}{\psframebox{~~} }
\putnode{n5}{n4}{5}{0}{\psframebox{~~} }
\putnode{n6}{n5}{5}{0}{\psframebox{~~} }
\putnode{n7}{n6}{5}{0}{\psframebox{~~} }

\putnode{n10}{n0}{30}{10}{Vector of pointers to Value context objects }
\putnode{n11}{n0}{40}{-40}{Value context }

\putnode{n20}{n0}{40}{-30}{ \psframebox{Context ID $\mid$ Function name $\mid$ Entry value pair $\mid$ Exit value pair}}
\nccurve[ncurv=0.5,angleA=270,angleB=90]{->}{n0}{n20}

\end{psframe}
\end{pspicture}
\caption{Storing value contexts}
\label{fig:valuecontexts}
\end{figure}

\item \emph{ContextTransition}: This module stores context transition graph which is a method of representing call strings and provides an API to access
it. The class diagram for this module in shown in figure \ref{fig:contexttransition}.

Each context is represented as a node in a graph. Each function call in the program adds an edge from a caller context to callee context. 
It is implemented in \emph{ContextTransition.java}. A Hashmap is used to store this information. The key consists of a combination of caller context id
and  \emph{ICFGnode} of the function call. The Value consist of the callee context id. Bi-directional mappings are maintained using two hash maps which stores 
mapping in both the directions. 

The key value mapping for the data structure is,
\newline
\emph{(caller context id, Call site) $\leftrightarrow $ callee context id}
\newline
\newline
\begin{figure}
\includegraphics[scale=0.8]{class_diagrams/updatedClassDiagrams/ContextTransition_C.eps}
\caption{Class Diagram for ContextTransition}
\label{fig:contexttransition}
\end{figure}

\item \emph{DFSolverLogger}: This module provides utilities for logging, measuring performance parameters of the core solver.
\item \emph{InterproceduralWorklist}: This module manages work list and applies a priority scheme to the work list. The class diagram for this module is 
shown in figure \ref{fig:interproceduralworklist}.

\begin{figure}[H]
\includegraphics[scale=0.8]{class_diagrams/updatedClassDiagrams/InterproceduralWL_C.eps}
\caption{Class Diagram for Interprocedural work list}
\label{fig:interproceduralworklist}
\end{figure}

\end{enumerate}



\chapter{User Manual of PRISM} \label{ap:A}
This section describes setting up PRISM on Ubuntu system. First section describes steps for setting up PRISM and how to generate an analyzer.
Second section describes how to analyze a program using generated analyzer.

\section{Steps for setting up PRISM on Ubuntu and generating the analyzer}

The following are the steps :
\begin{itemize}
 \item  Add all the locations of jar files to classpath by setting the environment variable \textbf{CLASSPATH}. 
 \item Create an environment variable PRISMROOT and store it in the url of PRISM root directory
 \item Create a directory inside \$PRISMROOT/darpan directory and name the directory as the name of the package defined in kulang 
 files. Copy all the specification files.
 \item Run the script \textbf{populatemodel.sh}. This will create a signature of the analysis.
 \item Update `\textbf{.ini}' file.
	\begin{itemize}
	 \item \$\textbf{PRISMROOT} : location of PRISM root directory.
	 \item \$\textbf{PRISMMODEL} : location of the signature file i.e.\textbf{Lpum.cdf}
	 \item \$\textbf{REPOSDIR} : location where test result should be dumped
	 \item \$\textbf{RREPOSDIR} : location from where IR should be read
	\end{itemize}
\item Update  \textbf{.prj} file and set the path of a program to be analyzed
\item Compile all the kulang files using command `\textbf{runKulangC filename}'. After successfull compilation, `\textbf{.java}' 
 files will be created and, the generated analyzer would be created and compiled in the same directory.
\end{itemize}

\section{Running an Analysis in PRISM}
Following are the steps to run an analysis in PRISM.
\begin{itemize}
 \item Write a program to be analyzed.
 \item Compile the program by using following command:
 
 \textbf{./cppfe --edg--gcc -O `location\_of\_IR' `filename' }
 
 location of IR should be same as the location present in \$\textbf{IRREPOSDIR}. For more options of cppfe, use the argument 
 `\textbf{--help}'.
 
 \item Go to the analysis directory and update `\textbf{runPrism.sh}' file. 
 \item Run the script `runPrism.sh' script. The results will be dumped into the director \$\textbf{REPOSDIR} as specified in `.ini' file
 \end{itemize}

\section{Steps for Setting up PRISM in Eclipse}
\begin{itemize}
 \item Open eclipse, create a new project and import the Driver and Client files of the analysis in the project.
 \item Go to project properties–build path–add external jar. Add all the jar files present in \textbf{\$PRISMROOT/lib}.
 \item Go to run configurations and create a new run configuration. In the VM arguments section, create an argument -DENVFILE=’path of .ini
file’ In the program arguments give first argument the path of .prj file and second argument the location where test results are to be dumped.
\item Write a c program to be analyzer. The name of the front end compiler to be used is cppfe. Compile the file using the command cppfe ’file-name’.
Also give the argument –edg–gcc and -O followed by location where IR should be generated. It should be the same as location of \textbf{\$IRREPOSDIR} given in
previous section.
\item Go to eclipse and run the Driver file using the run configuration created in the previous section.
\item The results will be dumped into the director \$\textbf{REPOSDIR} as specified in `.ini' file
\end{itemize}

\section{Steps for Running Incremental Driver} 
Following are the steps to run a Incremental driver:
\begin{itemize}
 \item Compile two programs (old and new programs).
 \item Go to eclipse $>$ Run Congigurations $>$ Java Application $>$ Arguments and add paths of both old and new IR as an argument. First argument should contain the path of old IR  
 which is followed by the path of new IR.
 \item Upon execution, command line will prompt asking for an user input to run incremental driver or not. Enter ``1'' to run incremental driver
 
\end{itemize}

 
 
 
 
\chapter{PRISM APIs}\label{ap:B}

This section describes the APIs that we have used in our implementation. An exhaustive list appears in PRISM documentation.

\section{API to Access IR}
\texttt{Expr} is the base class that represents the expression in IR. This class has sub classes to represent the type of expressions, such as Unary, Binary etc.
Following are some of the API to excess the expression in IR :
\begin{itemize}
 \item \texttt{getCorrNE(Set st)}: This function takes the pointer information at the program point as a parameter and returns a set of variables that an expression represents.
 
 For e.g. If \texttt{*b} is an expression and \texttt{\{b$\rightarrow$ a, b$\rightarrow c$\}} is a pointer information, then function will return \{a,c\}
 
 \item \texttt{RvalNE(boolean lr, Set aliasSet, Set copySet)} : This function takes pointer information as a parameter and returns a set of variables used in an expression
 
 For e.g. If \texttt{*b} is an expression and \texttt{\{b$\rightarrow$ a, b$\rightarrow$c\}} is a pointer information, then function will return \{a,b,c\}
 
 \item \texttt{pointsTo(Set st)} : This function takes a set of pointer information as a parameter and returns pointees of that expression
 \item \texttt{operands()} : returns the operands used in the expression
 \item \texttt{operator()} : returns operators used in the expression
 \item \texttt{lineNum()} : returns line number of the expression
 \item \texttt{NE()} : returns the NamedEntities of the operands in the expression
\end{itemize}

\section{APIs to find properties of NamedEntity}
\begin{itemize}
 \item \texttt{coveredBy(NamedEntity ne, boolean must)} : it returns whether a given namedEntity is may or must covered by the passed namedEntity.
 
 For e.g. a.b is covered by a
 \item \texttt{getDataType()} : returns the data type of the operand

 \item \texttt{isGlobal()} : returns true if the given namedEntity is global
 \item \texttt{getNEsFromReturn(Expr ex)} : returns the namedEntity of the variables used in the return statement
 \item \texttt{getNEsFromCall(Expr ex)} : returns the namedEntity of the variables used in the call statements
\end{itemize}


\chapter{Specifications of developed kulang queries}\label{ap:C}
\section{Reaching definition analysis}
Following is the specification for Intra-procedural reaching definition analysis.

\begin{lstlisting}
//Package declaration
package darpan.klgLib;

//Typedef
tup :: tuple(int,NamedEntity),
res :: set tup;

//Use declaration
fn_use darpan.klgLib;
fn_decl
res Meet (res, res),
res cartProduct ( set NamedEntity, set NamedEntity);

java_use darpan.klgLib.Aux;
java_decl
int line(Expr),
set tup HasElement(NamedEntity,res),
set NamedEntity IRefValNE@darpan.solverlib.FLAAnalysis(Expr,
					  boolean,IRObject),
set NamedEntity getNEs(Expr),
set NamedEntity getNEsFromCall(Expr),
set NamedEntity getNEsFromReturn(ASTnode),
boolean isLive(Expr,set NamedEntity),
set NamedEntity aliasClosure ( Expr, IRObject),
boolean isDref(Expr),
boolean isMust(set NamedEntity),
set NamedEntity getPtsto(res,Expr),
res getPointesOf(res,set NamedEntity),
set NamedEntity dref(res,Expr),
set NamedEntity getLhsSet(res,Expr),
NamedEntity getKillCandidate(set NamedEntity),
NamedEntity getIllegalNE();

//Mode
[FLA];

//Declaration of lattice type
lattice L ::  res; 

lCreaches_FG implements lCreaches_FG:

//Declaration of top value
top : (res){};

//Declaration of meet function
A meet B : A+B;

//Declaration of boundary value
BoundaryValue :(res){} ;

//Specifications of flow function for various statements
ForwardNodeflow( n: Symbol_AST, S: L )
	let
		ne=NE(n);
		exp=initExpr(n);
		line_no=line(exp);
		kill=HasElement(ne,S);
		def={[line_no,ne]};
	in
		(S-kill)+def;

ForwardNodeflow( n: Binary, S: L ) 
	if(operator(n)=='=')
	then
		let
			ne=NE(n);
			l_exp=lhs(n);
			l_var=getNEs(l_exp);
			line_no=line(l_exp);
			kill=HasElement(ne,S); 
			def={[line_no,ne]};
		in
			(S-kill)+def
	else
		S
	endif;


ForwardNodeflow( n: Unary, S: L )
	let
		ne=NE(n);
		line_no=line(n);
		kill=HasElement(ne,S);
		def={[line_no,ne]};
	in
		(S-kill)+def;

ForwardNodeflow( n: Call, S: L ) 
	S;

ForwardNodeflow( n: _, S: L ) 
	S;

ForwardEdgeflow(E: _, S: L) 
	S;
\end{lstlisting}


\section{Liveness-based Intra-procedural Reaching Definition Analysis}
Following is the specification for Liveness-based Intra-procedural Reaching definition analysis.
\begin{lstlisting}
//Package declaration
package darpan.klgLib;

//Typedef
tup :: tuple(int,NamedEntity),
livenesslattice :: set NamedEntity,
res :: set tup;

//Use declaration
fn_use darpan.klgLib;
fn_decl
res Meet (res, res),
res cartProduct ( set NamedEntity, set NamedEntity);

java_use darpan.klgLib.Aux;

java_decl
int print_set(set NamedEntity),
res removeNonLive(res,livenesslattice),
int line(Expr),
set tup HasElement(NamedEntity,res),
set NamedEntity IRefValNE@darpan.solverlib.FLAAnalysis(Expr,
					  boolean,IRObject),
livenesslattice getNE(Expr),
livenesslattice getNEs(Expr),
set NamedEntity getNEsFromCall(Expr),
set NamedEntity getNEsFromReturn(ASTnode),
boolean isLive(Expr,set NamedEntity),
boolean Check_datatype_call(Expr),
set NamedEntity aliasClosure ( Expr, IRObject),
livenesslattice useInRhs(res,Expr),
boolean check_datatype(Expr),
boolean check_datatype_lhs(Expr),
boolean isDref(Expr),
boolean isMust(set NamedEntity),
set NamedEntity getPtsto(res,Expr),
res getPointesOf(res,set NamedEntity),
set NamedEntity dref(res,Expr),
set NamedEntity getLhsSet(res,Expr),
NamedEntity getKillCandidate(set NamedEntity),
set NamedEntity emptySet(),
NamedEntity getIllegalNE();

//Mode
[FLA];

//Declaration of lattice types
Forwardlattice Rec ::  res;
Backwardlattice Liv :: livenesslattice;

lCreaches_FG implements lCreaches_FG:

//Declaration of types of forward and backward lattices
ForwardTop : (res){};
BackwardTop : (livenesslattice){};

//Declaration of meet functions
A ForwardMeet B : Meet(A,B);
A BackwardMeet B : A+B;

// Specification of boundry values
ForwardBoundaryValue : (res){};
BackwardBoundaryValue :(livenesslattice){} ;

// Specification of backward flow functions for various statement types
BackwardNodeflow( n: Binary, R: Rec, L:Liv )
if(check_datatype_lhs(lhs(n))==true && 
		      check_datatype(rhs(n))==true)
then
        let
                rt_expr=rhs(n);
                check =CHECK(n);
                lt_expr=lhs(n);
                rone=getNEs(rt_expr);
		lone=getNEs(lt_expr);
                x = if(operator(n)=='=')
                    then
                            if(isLive(lt_expr,L)==true)
                            then
                                 (L - lone) + rone
                            else
                                  L
                            endif
                   else
                                (L + lone) + rone
                   endif;
        in
                x
else
        L
endif;

BackwardNodeflow( n: Unary,R: Rec, L:Liv )
if(check_datatype(n)==true)
then
        let
             operands_ne=getNEs(n);
        in
             L+operands_ne
else
        L
endif;

BackwardNodeflow( n: Call, R: Rec, L:Liv )
if(Check_datatype_call(n)==true)
then
        let
             d = emptySet();
             UseInCall = getNEsFromCall(n);

        in
             d + L + UseInCall

else
        L
endif;

BackwardNodeflow( n: _,R: Rec, L:Liv)
        L;


BackwardEdgeflow(E: _,R: Rec, L:Liv)
        L;



ForwardNodeflow( n: Symbol_AST,R: Rec,L:Liv)
if(check_datatype(initExpr(n))==true)
then
        let
                ne=NE(n);
                exp=initExpr(n);
                check =CHECK(exp);
                line_no=line(exp);
                kill=HasElement(ne,R);
                def={[line_no,ne]};
                sur=(R-kill)+def;
                survive=removeNonLive(sur,L);
        in
                survive
else
        R
endif;



ForwardNodeflow(n: Binary,R: Rec,L:Liv)
if(check_datatype_lhs(lhs(n))==true && 
		      check_datatype(rhs(n))==true)
then
        let
                check =CHECK(n);
                rt_expr=rhs(n);
                l_exp=lhs(n);
                ne=NE(n);
                line_no=line(l_exp);
                kill=HasElement(ne,R); 
                def={[line_no,ne]};
                sur=(R-kill)+def;
                survive=if(operator(n)=='=')
                        then
                               removeNonLive(sur,L)
                        else
                               removeNonLive(R,L)

                        endif;
        in
                survive
else
        S
endif;





ForwardNodeflow( n: Unary,R: Rec,L:Liv)
if(check_datatype(n)==true)
then
        let
                check =CHECK(n);
                ne=NE(n);
                line_no=line(n);
                kill=HasElement(ne,R);
                def={[line_no,ne]};
                sur=(R-kill)+def;
                survive=removeNonLive(sur,L);
        in
                survive
else
        R
endif;

ForwardNodeflow( n: _,R: Rec,L:Liv)
        let
                survive=removeNonLive(R,L);
        in
                survive;

ForwardEdgeflow(E: _,R: Rec,L:Liv)
        let
                survive=removeNonLive(R,L);
        in
                survive;

Function res Meet ( A: res, B: res)
let
        diff=A+B;

in
        diff;

                                                                                                           


\end{lstlisting}

\section{Liveness-based Inter-procedural Reaching definition analysis}
Following is the specification for Liveness-based Inter-procedural Reaching definition analysis.

\begin{lstlisting}
package darpan.klgLib;

res :: set NamedEntity,
tup :: tuple(int,NamedEntity,NamedEntity),
tup1 :: tuple(NamedEntity,NamedEntity),
pntr_info :: set tup1,
pointstolattice :: set tup;


fn_use darpan.klgLib;
fn_decl
pointstolattice Meet (pointstolattice, pointstolattice),
pointstolattice cartProduct ( set NamedEntity, set NamedEntity);

java_use darpan.klgLib.Aux;
java_decl
set NamedEntity getNEs(Expr),
set NamedEntity getNEsFromCall(pntr_info,Expr),
set NamedEntity getNEsFromCall(Expr),
set NamedEntity getNEsFromReturn(ASTnode),
boolean isLive(Expr,set NamedEntity),
set NamedEntity aliasClosure ( Expr, IRObject),
boolean isDref(Expr),
pointstolattice HasElement(NamedEntity,pointstolattice),
set NamedEntity removeIndirection@darpan.klgLib.AnalysisAPI(Expr, pointstolattice) ,
boolean isMust(set NamedEntity),
set NamedEntity getPtsto(pntr_info,Expr),
pntr_info getPointesOf(pntr_info,set NamedEntity),
set NamedEntity dref(pointstolattice,Expr),
set NamedEntity getLhsSet(pntr_info,Expr),
set NamedEntity getKillCandidate(pntr_info,res,Expr),
NamedEntity getIllegalNE(),
pntr_info removeNonLive(set NamedEntity, pntr_info),
set tup cst(set tup),
set NamedEntity emptySet(),
set NamedEntity useInLhsDref(pntr_info,Expr),
set NamedEntity useInRhs(pntr_info,Expr,boolean),
pointstolattice	getSurvive(pntr_info,pointstolattice),
boolean check_datatype_lhs(Expr),
boolean check_datatype_lne(NamedEntity),
boolean check_datatype(Expr),
boolean check_datatype_new(NamedEntity),
NamedEntity getN(Expr),
int Line(Expr),
int Line(ASTnode),
NamedEntity getRvalue(Expr),
NamedEntity pointsToInfo(NamedEntity,pntr_info),
boolean isEqualNe(NamedEntity, NamedEntity),
boolean isStrongUpdate(Expr);

[FLA];

Forwardlattice L1 ::  pointstolattice; 
Backwardlattice L2 ::  res;

sLiveness_FG implements sLiveness_FG:

ForwardTop : (pointstolattice){};
BackwardTop : (res){};

A ForwardMeet B : A+B;
A BackwardMeet B : A+B;

ForwardBoundaryValue: (pointstolattice){};
BackwardBoundaryValue : (res){};

BackwardNodeflow( n: Unary, S: L1, S1: L2 ) 
	let
		pntr=<<a :(pntr_info) {} ; x <- S;
			     a + {[atIndex(x,1), atIndex(x,2)]}>>; //extracting 
								    pointer information
		
		useinrhs = if(check_datatype(n) == false) // if operand 
							     is a pointer
			   then
				useInRhs(pntr,n,true) // get the pointees
			   else
$$				getNEs(n)
			   endif;
		
	in
		useinrhs + S1;

BackwardNodeflow( n: Binary, S: L1, S1: L2 )
let
        opr = operator(n);
        d = emptySet();
        lt_expr = lhs(n);
        rt_expr = rhs(n);
	lNE = getNEs(lt_expr);
	rNE = getNEs(rt_expr);
        ss = d + S1;
	pntr=<<a :(pntr_info) {} ; x <- S;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;
	chck_livness = isLive(lt_expr,S1); // checking the liveness
					      of lhs operands
        useinlhs = if(!check_datatype_lhs(lt_expr))
		   then	
			if ( ( opr == '=' ))
			then
				useInLhsDref(pntr,lt_expr)
			else
				useInRhs(pntr,n,chck_livness)
			endif
		   else
			if ( ( opr == '=' ))
                        then
				(set NamedEntity){}
                        else
				lNE
                        endif
		   endif;
        useinrhs = if(!check_datatype(rt_expr))
		   then
			useInRhs(pntr,rt_expr,chck_livness)
		   else
			if(operator(n) == '=')
                        then
				if(isLive(lt_expr,S1) == true)
				then
                               		rNE
				else
					(set NamedEntity){}
				endif
			else
				rNE
                    	endif
		   endif;

        killcandidate = if(!check_datatype_lhs(lt_expr))
		       then
				if ( ( opr == '=' ))
				then
					getKillCandidate(pntr,S1,lt_expr)
				else
					(set NamedEntity){}
				endif
			else
				if(operator(n) == '=')
				then
					lNE
				else
					(set NamedEntity){}
				endif
			endif;
	gen = useinlhs + useinrhs + ss;
	sur = gen - killcandidate;
in
	sur;

BackwardNodeflow( n: Returnstmt, S: L1, S1: L2 ) 
let
	re = retExpr(n);
	pntr = <<a :(pntr_info) {} ; x <- S;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;
	s = useInRhs(pntr,re,true);
in
	S1 + s;

BackwardNodeflow( n: Call, S: L1, S1: L2 ) 
let
	d = emptySet();
	pntr = <<a :(pntr_info) {} ; x <- S;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;
	nes = if(check_datatype(n) == false)
              then
		getNEsFromCall(pntr,n)
	      else
		getNEsFromCall(n)
	      endif;
in
	d + nes + S1;


BackwardNodeflow( n: _, S: L1 ,S1: L2) 
	S1;

BackwardEdgeflow(E: _, S: L1 ,S1: L2) 
	S1;

ForwardNodeflow( n: Unary, S: L1, S1: L2 )
let
	line = Line(n);
	pntr = <<a :(pntr_info) {} ; x <- S;
                       a + {[atIndex(x,1), atIndex(x,2)]}>>;

	useinrhs = if(check_datatype(n) == false)
                   then
                         useInRhs(pntr,n,true)
                   else
                         getNEs(n)
                   endif;
	def = <<a :(pointstolattice) {} ; x <- useinrhs;
		a+
		    if(!isIllegalNE(x))
		    then
			 {[line,x,pointsToInfo(x,pntr)]}
		    else
			 {}
		    endif
			>>;
	ne = NE(n);
	kill = HasElement(ne,S);
in 
	(S - kill) + def;

ForwardNodeflow( n: Function_AST, S: L1, S1: L2 )
let
	para = parameterAST(n);
	line = Line(n);
	total_def = << a: (pointstolattice) {} ; x <- para;
                    a+
                        if(!isIllegalNE(x))
                        then
                            {[line,x,getIllegalNE()]}
                        else
                            {}
                        endif >>;
	def = <<a :(pntr_info) {} ; x <- total_def;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;
	kill = << a : (pointstolattice)  {} ; x <- S;
		 a+ 
			<< b : (pointstolattice) {} ; y <- total_def;
				if(isEqualNe(atIndex(x,1),atIndex(y,1)))
				then
					{x}
				else
					{}
				endif
			>>
		
  		>>;
	surv = removeNonLive(S1,def);
	survive = getSurvive(surv,total_def);
in
	survive; 

ForwardNodeflow( n: Symbol_AST, S: L1, S1: L2 )
let
	exp = initExpr(n);
	ne = NE(n);
	line = Line(exp);
	kill = HasElement(ne,S);
	def = if(!check_datatype_new(ne))
	     then
		{[line,ne,getRvalue(exp)]}
	     else
		{[line,ne,getIllegalNE()]}
	     endif;
	su = (S - kill) + def;
	pntr = <<a :(pntr_info) {} ; x <- su;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;
	surv = removeNonLive(S1,pntr);
	survive = getSurvive(surv,su);
in
	survive;

ForwardNodeflow( n: Binary, S: L1, S1: L2 ) 
let
	lt_expr = lhs(n);
	rt_expr = rhs(n);
	line = Line(lt_expr); 
	ne = NE(n);
	pntr_info1 = <<a :(pntr_info) {} ; x <- S;
	             a + {[atIndex(x,1), atIndex(x,2)]}>>;
	rne = if(!check_datatype_lhs(rhs(n)))
	      then
		getPtsto(pntr_info1,rt_expr)
	      else
		getNEs(rt_expr)
	      endif;
	lne = if(!check_datatype_lhs(lhs(n)))
 	     then
		 getLhsSet(pntr_info1,lt_expr)
	     else
		getNEs(lt_expr)
	     endif;
	rne_new = if(rne == emptySet())
		then
			{getIllegalNE()}
		else
			rne
		endif;
	gn = if(operator(n) == '=')
	    then
		<< a: (pointstolattice) {} ; x <- lne;
                    a+
		    	if(check_datatype_lne(x))
	    		then
                       		<< b: (pointstolattice) {} ; t <- rne_new;
                               	   b+
                                     	if(!isIllegalNE(x))
					then
						{[line,x,t]}
					else
						{}
                                        endif
                           	>>
		         else
				{[line,x,getIllegalNE()]}
		   	endif
                >>
	    else
		(pointstolattice) {}
	    endif;
	kl = if(!check_datatype_lhs(lhs(n)))
	     then
		if((isMust(lne)))
		then
			if(isStrongUpdate(lt_expr))
			then
				getPointesOf(pntr_info1,lne)
			else
				(pntr_info){}
			endif		
			
		else
			(pntr_info){}
		endif
	      else
			(pntr_info){}
	      endif;
	kill = if(!check_datatype_lhs(lhs(n)))
	     then
		 << a: (pointstolattice) {} ; x <- kl;
                    a+
                           << b: (pointstolattice) {} ; t <- S;
                                   b+
                                        if(atIndex(x,0)==atIndex(t,1))
                                        then
                                                {t}
                                        else
                                               (pointstolattice){}
                                        endif
                           >>
                >>
	    else
		HasElement(ne,S)
	    endif;
	su = (S - kill) + gn;
	temp = emptySet();
	liveset = temp + S1;
	pntr = <<a :(pntr_info) {} ; x <- su;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;

	surv1 = removeNonLive(liveset,pntr);
	surv = removeNonLive(liveset,surv1);
	survive=getSurvive(surv,su);

in
	survive;

ForwardNodeflow( n: _, S: L1 ,S1: L2) 
let
	temp = emptySet();
	liveset = temp + S1;
	pntr = <<a :(pntr_info) {} ; x <- S;
                     a + {[atIndex(x,1), atIndex(x,2)]}>>;
	surv = removeNonLive(liveset,pntr);
	survive = << a: (pointstolattice) {} ; x <- surv;
                    a+
                           << b: (pointstolattice) {} ; t <- S;
                                   b+
                                        if(atIndex(x,0)==atIndex(t,1))
                                        then
                                                {t}
                                        else
                                               (pointstolattice){}
                                        endif
                           >>
                >>;

in
	survive;

ForwardEdgeflow(E: _, S: L1 ,S1: L2) 
	S;

\end{lstlisting}





\end{document}
